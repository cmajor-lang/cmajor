
// This file was generated by tools/scripts/create_embedded_files.py

//==============================================================================
static constexpr std::string_view testFunctionLibrary = "//\n"
    "//     ,ad888ba,                              88\n"
    "//    d8\"'    \"8b\n"
    "//   d8            88,dba,,adba,   ,aPP8A.A8  88     (C)2024 Cmajor Software Ltd\n"
    "//   Y8,           88    88    88  88     88  88\n"
    "//    Y8a.   .a8P  88    88    88  88,   ,88  88     https://cmajor.dev\n"
    "//     '\"Y888Y\"'   88    88    88  '\"8bbP\"Y8  88\n"
    "//                                           ,88\n"
    "//                                        888P\"\n"
    "//\n"
    "//  This code may be used under either a GPLv3 or commercial\n"
    "//  license: see LICENSE.md for more details.\n"
    "\n"
    "\n"
    "/*\n"
    "    This file defines the set of standard unit-test functions that are built\n"
    "    into the test suite.\n"
    "\n"
    "    Any functions in here can be invoked inside a .cmajtest file by putting them\n"
    "    on a line that starts with a double-hash. So for example:\n"
    "\n"
    "    ## expectError (\"2:11: error: Array elements cannot be references\")\n"
    "\n"
    "    will invoke the expectError() function declared below.\n"
    "\n"
    "    You can run a .cmajtest file with the command line utility:\n"
    "\n"
    "      $ cmaj test mytest.cmajtest\n"
    "\n"
    "    The tests in this file are built into the app, but you can also write your\n"
    "    own functions, using these as a guide to how to do that.\n"
    "*/\n"
    "\n"
    "'use strict';\n"
    "\n"
    "//==============================================================================\n"
    "/// This class can be used to parse a patch manifest to get a list of its\n"
    "/// source files, and to resolve its externals.\n"
    "class PatchManifest\n"
    "{\n"
    "    constructor (testSection, file)\n"
    "    {\n"
    "        this.testSection = testSection;\n"
    "        this.manifestFile = file;\n"
    "        this.manifest = JSON.parse (this.manifestFile.read());\n"
    "\n"
    "        if (! this.manifest?.CmajorVersion)\n"
    "            this.error = { severity: \"error\", fullDescription: \"Not a valid manifest\" };\n"
    "    }\n"
    "\n"
    "    createProgram()\n"
    "    {\n"
    "        const program = new Program();\n"
    "\n"
    "        let transformer;\n"
    "\n"
    "        if (this.manifest.sourceTransformer != null)\n"
    "            transformer = new SourceTransformer (this.manifestFile.getSibling (this.manifest.sourceTransformer).path);\n"
    "\n"
    "        for (const source of this.getSourceFiles())\n"
    "        {\n"
    "            let sourceToParse = source;\n"
    "\n"
    "            if (transformer)\n"
    "            {\n"
    "                // this.testSection.logMessage (sourceToParse);\n"
    "\n"
    "                let response = transformer.transform (source.path, source.read());\n"
    "\n"
    "                if (isError (response))\n"
    "                    return response;\n"
    "\n"
    "                sourceToParse = response;\n"
    "            }\n"
    "\n"
    "            const error = program.parse (sourceToParse);\n"
    "\n"
    "            if (isError (error))\n"
    "            {\n"
    "                program.release();\n"
    "                return error;\n"
    "            }\n"
    "        }\n"
    "\n"
    "        return program;\n"
    "    }\n"
    "\n"
    "    getSourceFiles()\n"
    "    {\n"
    "        let list = [];\n"
    "\n"
    "        if (Array.isArray (this.manifest.source))\n"
    "        {\n"
    "            for (let i = 0; i < this.manifest.source.length; ++i)\n"
    "                list.push (this.manifestFile.getSibling (this.manifest.source[i]));\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            list.push (this.manifestFile.getSibling (this.manifest.source));\n"
    "        }\n"
    "\n"
    "        return list;\n"
    "    }\n"
    "\n"
    "    getExternals()\n"
    "    {\n"
    "        let externals = {};\n"
    "\n"
    "        const externalDefs = this.manifest.externals;\n"
    "\n"
    "        if (externalDefs)\n"
    "            for (const [key, value] of Object.entries (externalDefs))\n"
    "                externals[key] = this.replaceStringsWithAudioData (value);\n"
    "\n"
    "        return externals;\n"
    "    }\n"
    "\n"
    "    replaceStringsWithAudioData (o)\n"
    "    {\n"
    "        if (! o)\n"
    "            return o;\n"
    "\n"
    "        if (typeof o == \"string\")\n"
    "        {\n"
    "            const audioFile = this.manifestFile.getSibling (o);\n"
    "            const audioData = audioFile.readAudioData();\n"
    "\n"
    "            if (typeof audioData == \"object\" && ! isError (audioData))\n"
    "                return audioData;\n"
    "        }\n"
    "\n"
    "        if (Array.isArray (o))\n"
    "        {\n"
    "            for (let i = 0; i < o.size; ++i)\n"
    "                o[i] =  this.replaceStringsWithAudioData (o[i]);\n"
    "        }\n"
    "\n"
    "        if (typeof o == \"object\")\n"
    "        {\n"
    "            for (let i in o)\n"
    "                if (Object.prototype.hasOwnProperty.call (o, i))\n"
    "                    o[i] =  this.replaceStringsWithAudioData (o[i]);\n"
    "        }\n"
    "\n"
    "        return o;\n"
    "    }\n"
    "}\n"
    "\n"
    "//==============================================================================\n"
    "/*  This test attempts to compile and run a processor, checking its output.\n"
    "\n"
    "    Helper function to ensure that cpp performer tests on windows do not trigger\n"
    "    a test failure, but an unsupported test. Failing with a 'Failed to compile 'xxx' is not recognized\n"
    "*/\n"
    "function reportFailOrUnsupported (testSection, error)\n"
    "{\n"
    "    if (error.message == \"Language feature not yet implemented: cpp performer on windows!\" ||\n"
    "        error.message.substring (0, 19) == \"Failed to compile '\")\n"
    "    {\n"
    "        testSection.reportUnsupported (error);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "\n"
    "    testSection.reportFail (error);\n"
    "}\n"
    "\n"
    "//==============================================================================\n"
    "/*  This test attempts to compile and run a processor, checking its output.\n"
    "\n"
    "    The test expects to find a main processor which has an output stream (or an\n"
    "    output event) that emits int32 values.\n"
    "\n"
    "    It will then run the processor, reading frames (or events) from its output,\n"
    "    and uses them in the following way:\n"
    "\n"
    "    - if it encounters a 1, it continues rendering\n"
    "    - if it encounters a 0, it stops and marks the test as having failed\n"
    "    - when it encounters a -1, it stops the test\n"
    "\n"
    "    This lets you write a processor that performs a rendering task and checks its\n"
    "    own output, sending a stream of 1s if all is well, or a 0 if not.\n"
    "\n"
    "    (Obviously if the code fails to compile or a processor can't be found, then\n"
    "    the test fails)\n"
    "\n"
    "    e.g.\n"
    "    ## testProcessor()\n"
    "*/\n"
    "function testProcessor (expectedResult, options)\n"
    "{\n"
    "    let sampleCount = 100;\n"
    "    let testSection = getCurrentTestSection();\n"
    "\n"
    "    let timingInfo = {};\n"
    "    let engine = buildEngineWithLoadedProgram (testSection, options, timingInfo);\n"
    "\n"
    "    if (isError (engine))\n"
    "    {\n"
    "        testSection.reportFail (engine);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let outputs = engine.getOutputEndpoints();\n"
    "    let resultHandle = engine.getEndpointHandle (outputs[0].endpointID);\n"
    "\n"
    "    let error = engine.link();\n"
    "\n"
    "    if (isError (error))\n"
    "    {\n"
    "        testSection.reportFail (error);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let performer = engine.createPerformer();\n"
    "    performer.setBlockSize (sampleCount);\n"
    "    error = performer.advance();\n"
    "\n"
    "    if (isError (error))\n"
    "    {\n"
    "        testSection.reportFail (error);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let results = [];\n"
    "\n"
    "    if (outputs[0].endpointType == \"event\")\n"
    "    {\n"
    "        let events = performer.getOutputEvents (resultHandle);\n"
    "\n"
    "        for (let i = 0; i < events.length; ++i)\n"
    "            results.push (events[i].event);\n"
    "    }\n"
    "    else if (outputs[0].endpointType == \"stream\")\n"
    "    {\n"
    "        results = performer.getOutputFrames (resultHandle);\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        testSection.reportFail (\"Unsupported output endpoint type \" + outputs[0].endpointType);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let successes = 0;\n"
    "    let fails = 0;\n"
    "\n"
    "    for (let i = 0; i < results.length; ++i)\n"
    "    {\n"
    "        const value = results[i];\n"
    "\n"
    "        if (value < 0)\n"
    "            break;\n"
    "\n"
    "        if (value > 0)\n"
    "            ++successes;\n"
    "        else\n"
    "            ++fails;\n"
    "    }\n"
    "\n"
    "    const outputResult = (successes > 0 && fails == 0);\n"
    "\n"
    "    if (expectedResult === undefined || expectedResult)\n"
    "    {\n"
    "        if (outputResult)\n"
    "            testSection.reportSuccess();\n"
    "        else\n"
    "            testSection.reportFail (\"Processor test failed\");\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        if (! outputResult)\n"
    "            testSection.reportSuccess();\n"
    "        else\n"
    "            testSection.reportFail (\"Processor test succeeded but we were expecting it to fail\");\n"
    "    }\n"
    "}\n"
    "\n"
    "//==============================================================================\n"
    "/*  This test passes if the code compiles with the same error provided as an\n"
    "    argument.\n"
    "\n"
    "    The chunk of code that is provided is implicitly wrapped in a namespace before\n"
    "    being compiled, so you can write compact tests that just contain a bare list\n"
    "    of functions (it's normally a syntax error to declare a function at global scope).\n"
    "    If you want to\n"
    "\n"
    "    ## expectError (\"2:11: error: Array elements cannot be references\")\n"
    "\n"
    "    If you perform this test with no arguments, i.e:\n"
    "\n"
    "    ## expectError\n"
    "\n"
    "    ..then it will re-write this line in your test file, adding the actual error\n"
    "    encountered, which makes it easy to get the correct error string into the test\n"
    "    file without needing to copy-paste it from the compiler output manually.\n"
    "*/\n"
    "function expectError (expectedError, options)\n"
    "{\n"
    "    let testSection = getCurrentTestSection();\n"
    "\n"
    "    let sourceToCompile;\n"
    "\n"
    "    if (options != null && options.doNotWrapInTestNamespace)\n"
    "        sourceToCompile = testSection.source + testSection.globalSource;\n"
    "    else\n"
    "        sourceToCompile = \"namespace tests { \" + testSection.source + \" }\\n\"\n"
    "                            + \"processor TestProcessor { output stream float32 out; void main() { advance(); } }\\n\"\n"
    "                            + testSection.globalSource;\n"
    "\n"
    "    let program = new Program();\n"
    "    let error = program.parse (sourceToCompile);\n"
    "    let newErrorLine = getErrorReportString (error);\n"
    "\n"
    "    if (! isError (error))\n"
    "    {\n"
    "        let engine = createEngine (options);\n"
    "        updateBuildSettings (engine, 44100, 1024, false, options);\n"
    "\n"
    "        error = engine.load (program);\n"
    "        newErrorLine += getErrorReportString (error);\n"
    "\n"
    "        if (! isError (error))\n"
    "            newErrorLine += getErrorReportString (engine.link());\n"
    "    }\n"
    "\n"
    "    if (newErrorLine.length == 0)\n"
    "    {\n"
    "        testSection.reportFail (\"Failed to fail\");\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    if (expectedError == null || expectedError.length == 0)\n"
    "    {\n"
    "        testSection.reportSuccess();\n"
    "        testSection.logMessage (\"Updating error text to '\" + newErrorLine + \"'\");\n"
    "\n"
    "        if (options == null)\n"
    "            testSection.updateTestHeader (\"## expectError (\\\"\" + newErrorLine.replace (/\\\"/g, \"\\\\\\\"\") + \"\\\")\");\n"
    "        else\n"
    "            testSection.updateTestHeader (\"## expectError (\\\"\" + newErrorLine.replace (/\\\"/g, \"\\\\\\\"\") + \"\\\", \" + JSON.stringify (options) + \")\");\n"
    "    }\n"
    "    else if (newErrorLine == expectedError)\n"
    "    {\n"
    "        testSection.reportSuccess();\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        if (newErrorLine == \"error: Language feature not yet implemented: cpp performer on windows!\" ||\n"
    "            newErrorLine.substring (0, 26) == \"error: Failed to compile '\")\n"
    "        {\n"
    "            testSection.reportUnsupported (error);\n"
    "            return;\n"
    "        }\n"
    "\n"
    "        testSection.logCompilerError (error);\n"
    "        testSection.reportFail (\"error mismatch\");\n"
    "\n"
    "        testSection.logMessage (\"Expecting \" + expectedError);\n"
    "        testSection.logMessage (\"Got       \" + newErrorLine);\n"
    "    }\n"
    "}\n"
    "\n"
    "//==============================================================================\n"
    "/*\n"
    "    This test takes the code provided, and finds all the functions declared which\n"
    "    return a bool and take no arguments. It then attempts to call each one, expecting\n"
    "    them all to return true. If any return false, the test fails and it reports\n"
    "    which of the functions failed.\n"
    "\n"
    "    The chunk of code that is provided is implicitly wrapped in a namespace before\n"
    "    being compiled, so you can write compact tests that just contain a bare list\n"
    "    of functions (it's a syntax error to declare a function at global scope).\n"
    "\n"
    "    ## testFunction()\n"
    "*/\n"
    "function testFunction (options)\n"
    "{\n"
    "    let testSection = getCurrentTestSection();\n"
    "    let sourceToCompile = \"namespace tests { \" + testSection.source + \" }\" + testSection.globalSource;\n"
    "    let program = new Program();\n"
    "    let error = program.parse (sourceToCompile);\n"
    "\n"
    "    if (isError (error))\n"
    "    {\n"
    "        testSection.reportFail (error);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let functions = findTestFunctions (program);\n"
    "\n"
    "    if (functions.length == 0)\n"
    "    {\n"
    "        testSection.reportFail (\"No test functions found\");\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let callAllTestFunctions = \"\";\n"
    "\n"
    "    for (let i = 0; i < functions.length; i++)\n"
    "        callAllTestFunctions += \"        result <- (tests::\" + functions[i] + \"() ? 1 : 0); advance();\\n\";\n"
    "\n"
    "    let processorSource = \"processor FunctionTester [[main]]\\n\"\n"
    "                        + \"{\\n\"\n"
    "                        + \"    output value int result;\\n\"\n"
    "                        + \"    void main() {\\n\"\n"
    "                        + callAllTestFunctions\n"
    "                        + \"        result <- -1;\\n\"\n"
    "                        + \"        advance();\\n\"\n"
    "                        + \"    }\\n\"\n"
    "                        + \"}\\n\";\n"
    "\n"
    "    error = program.parse (processorSource);\n"
    "\n"
    "    if (isError (error))\n"
    "    {\n"
    "        testSection.reportFail (error);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let engine = createEngine (options);\n"
    "    updateBuildSettings (engine, 44100, 1, ! options?.failOnWarnings, options);\n"
    "    error = engine.load (program);\n"
    "\n"
    "    if (isError (error) || (options?.failOnWarnings && isErrorOrWarning (error)))\n"
    "    {\n"
    "        testSection.reportFail (error);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let outputs = engine.getOutputEndpoints();\n"
    "    let resultHandle = engine.getEndpointHandle (outputs[0].endpointID);\n"
    "\n"
    "    error = engine.link();\n"
    "\n"
    "    if (isError (error) || (options?.failOnWarnings && isErrorOrWarning (error)))\n"
    "    {\n"
    "        testSection.reportFail (error);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let failingTests = [];\n"
    "    let performer = engine.createPerformer();\n"
    "\n"
    "    for (let i = 0; i < functions.length + 1; i++)\n"
    "    {\n"
    "        performer.setBlockSize (1);\n"
    "\n"
    "        let error = performer.advance();\n"
    "\n"
    "        if (isError (error))\n"
    "        {\n"
    "            testSection.reportFail (error);\n"
    "            return;\n"
    "        }\n"
    "\n"
    "        let result = performer.getOutputValue (resultHandle);\n"
    "\n"
    "        if (Number.isInteger (result))\n"
    "        {\n"
    "            if (result == 0)\n"
    "                failingTests.push (functions[i]);\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            testSection.reportFail (result);\n"
    "        }\n"
    "    }\n"
    "\n"
    "    if (failingTests.length != 0)\n"
    "    {\n"
    "        testSection.reportFail (failingTests.length + \" functions failed: \" + failingTests.join (\", \"));\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    testSection.reportSuccess();\n"
    "}\n"
    "\n"
    "//==============================================================================\n"
    "/**\n"
    "    This test just attempts to compile the code, failing if there are any errors.\n"
    "\n"
    "    If it is given the optional argument `false` then it doesn't attempt to link\n"
    "    the code, just to parse and load it into an engine.\n"
    "\n"
    "    ## testCompile()\n"
    "*/\n"
    "function testCompile (options)\n"
    "{\n"
    "    let testLink = true;\n"
    "    let testWithoutEndpoints = true;\n"
    "\n"
    "    if (options == undefined)\n"
    "        options = {};\n"
    "\n"
    "    if (options.testLink !== undefined)             testLink             = options.testLink;\n"
    "    if (options.testWithoutEndpoints !== undefined) testWithoutEndpoints = options.testWithoutEndpoints;\n"
    "\n"
    "\n"
    "    let testSection = getCurrentTestSection();\n"
    "    let timingInfo = {};\n"
    "    let engine = buildEngineWithLoadedProgram (testSection, options, timingInfo);\n"
    "    let error;\n"
    "\n"
    "    if (isError (engine, options))\n"
    "    {\n"
    "        reportFailOrUnsupported (testSection, engine);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let inputs = engine.getInputEndpoints();\n"
    "    let outputs = engine.getOutputEndpoints();\n"
    "\n"
    "    for (let i = 0; i < inputs.length; i++)\n"
    "        engine.getEndpointHandle (inputs[i].endpointID);\n"
    "\n"
    "    for (let i = 0; i < outputs.length; ++i)\n"
    "        engine.getEndpointHandle (outputs[i].endpointID);\n"
    "\n"
    "    if (testLink)\n"
    "    {\n"
    "        error = engine.link();\n"
    "\n"
    "        if (isError (error, options))\n"
    "        {\n"
    "            reportFailOrUnsupported (testSection, error);\n"
    "            return;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    engine.unload();\n"
    "\n"
    "    if (testWithoutEndpoints)\n"
    "    {\n"
    "        error = buildEngineWithLoadedProgram (testSection, options, timingInfo, engine);\n"
    "\n"
    "        if (isError (error, options))\n"
    "        {\n"
    "            testSection.reportFail (error);\n"
    "            return;\n"
    "        }\n"
    "\n"
    "        if (testLink)\n"
    "        {\n"
    "            error = engine.link();\n"
    "\n"
    "            if (isError (error, options))\n"
    "            {\n"
    "                reportFailOrUnsupported (testSection, error);\n"
    "                return;\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    testSection.reportSuccess();\n"
    "}\n"
    "\n"
    "//==============================================================================\n"
    "/* This test checks whether the console output matches what was expected\n"
    "\n"
    "    e.g.\n"
    "    ## testConsole (\"hello_world\")\n"
    "\n"
    "*/\n"
    "function testConsole (expectedConsoleMsg, options)\n"
    "{\n"
    "    let testSection = getCurrentTestSection();\n"
    "    let timingInfo = {};\n"
    "    let engine = buildEngineWithLoadedProgram (testSection, options, timingInfo);\n"
    "\n"
    "    if (isError (engine, options))\n"
    "    {\n"
    "        testSection.reportFail (engine);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let outputs = engine.getOutputEndpoints();\n"
    "    let consoleIndex = -1;\n"
    "\n"
    "    if (outputs)\n"
    "        for (let i = 0; i < outputs.length; ++i)\n"
    "            if (outputs[i].endpointID == \"console\")\n"
    "                consoleIndex = i;\n"
    "\n"
    "    if (consoleIndex < 0)\n"
    "        testSection.reportFail (\"no console output stream found\");\n"
    "\n"
    "    let consoleHandle = engine.getEndpointHandle (\"console\");\n"
    "\n"
    "    if (isError (consoleHandle))\n"
    "    {\n"
    "        testSection.reportFail (consoleHandle);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let error = engine.link();\n"
    "\n"
    "    if (isError (error))\n"
    "    {\n"
    "        testSection.reportFail (error);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let performer = engine.createPerformer();\n"
    "\n"
    "    let framesToRender = 1024;\n"
    "    let framesPerBlock = 64;\n"
    "    let consoleMsg = \"\";\n"
    "\n"
    "    while (framesToRender > 0)\n"
    "    {\n"
    "        performer.setBlockSize (framesPerBlock);\n"
    "        performer.advance();\n"
    "\n"
    "        let result = performer.getOutputEvents (consoleHandle);\n"
    "\n"
    "        if (result)\n"
    "        {\n"
    "            for (let i = 0; i < result.length; i++)\n"
    "            {\n"
    "                if (typeof result[i].event == \"object\")\n"
    "                    consoleMsg += JSON.stringify (result[i].event);\n"
    "                else\n"
    "                    consoleMsg += result[i].event;\n"
    "            }\n"
    "        }\n"
    "\n"
    "        framesToRender -= framesPerBlock;\n"
    "    }\n"
    "\n"
    "    if (! expectedConsoleMsg || expectedConsoleMsg.length == 0)\n"
    "    {\n"
    "        testSection.reportSuccess();\n"
    "        testSection.logMessage (\"Updating console text to '\" + consoleMsg + \"'\");\n"
    "        testSection.updateTestHeader (\"## testConsole (\" + JSON.stringify (consoleMsg) + \")\");\n"
    "    }\n"
    "    else if (consoleMsg == expectedConsoleMsg)\n"
    "    {\n"
    "        testSection.reportSuccess();\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        testSection.reportFail (\"console mismatch\");\n"
    "        testSection.logMessage (\"Expecting \" + expectedConsoleMsg);\n"
    "        testSection.logMessage (\"Got       \" + consoleMsg);\n"
    "    }\n"
    "}\n"
    "\n"
    "\n"
    "//==============================================================================\n"
    "/*\n"
    "    This test builds a processor and renders a given amount of data through it,\n"
    "    measuring and reporting its performance.\n"
    "\n"
    "    e.g.\n"
    "    ## performanceTest ({ frequency:44100, minBlockSize:4, maxBlockSize: 1024, samplesToRender:100000 })\n"
    "    ## performanceTest ({ frequency:44100, minBlockSize:4, maxBlockSize: 1024, samplesToRender:100000, patch: \"testPatch.cmajorpatch\" })\n"
    "*/\n"
    "\n"
    "function performanceTest (options)\n"
    "{\n"
    "    let testSection = getCurrentTestSection();\n"
    "\n"
    "    if (getEngineName() == \"webview\")\n"
    "    {\n"
    "        testSection.reportUnsupported (\"engine type \" + getEngineName() + \" not supported\");\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let timingInfo = {};\n"
    "    let engine = buildEngineWithLoadedProgram (testSection, options, timingInfo);\n"
    "\n"
    "    if (isError (engine, options))\n"
    "    {\n"
    "        testSection.reportFail (engine);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    if (engine.getBuildSettings().optimisationLevel == 0)\n"
    "    {\n"
    "        testSection.reportUnsupported (\"Test disabled for --O0 as it will take too long\");\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let inputEndpoints = engine.getInputEndpoints();\n"
    "\n"
    "    for (let i = 0; i < inputEndpoints.length; i++)\n"
    "        inputEndpoints[i].handle = engine.getEndpointHandle (inputEndpoints[i].endpointID);\n"
    "\n"
    "    let outputEndpoints = engine.getOutputEndpoints();\n"
    "\n"
    "    for (let i = 0; i < outputEndpoints.length; i++)\n"
    "        outputEndpoints[i].handle = engine.getEndpointHandle (outputEndpoints[i].endpointID);\n"
    "\n"
    "    timingInfo.linkTime = engine.link ();\n"
    "\n"
    "    if (isError (timingInfo.linkTime, options))\n"
    "    {\n"
    "        reportFailOrUnsupported (testSection, timingInfo.linkTime);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let totalTime = timingInfo.loadTime  + timingInfo.linkTime;\n"
    "\n"
    "    if (timingInfo.parseTime != undefined)\n"
    "    {\n"
    "        totalTime += timingInfo.parseTime;\n"
    "        testSection.logMessage (\"Parse time: \" + Math.round (timingInfo.parseTime * 1000) + \" ms\");\n"
    "    }\n"
    "\n"
    "    testSection.logMessage (\"Load time : \" + Math.round (timingInfo.loadTime * 1000) + \" ms\");\n"
    "    testSection.logMessage (\"Link time : \" + Math.round (timingInfo.linkTime * 1000) + \" ms\");\n"
    "    testSection.logMessage (\"Total     : \" + Math.round (totalTime * 1000) + \" ms\");\n"
    "\n"
    "    let performer = engine.createPerformer();\n"
    "    let blockSize = options.minBlockSize;\n"
    "    let inputFrames = [];\n"
    "\n"
    "    for (let i = 0; i < options.maxBlockSize; i++)\n"
    "        inputFrames[i] = i / options.maxBlockSize;\n"
    "\n"
    "    while (blockSize <= options.maxBlockSize)\n"
    "    {\n"
    "        performer.setBlockSize (blockSize);\n"
    "\n"
    "        for (let i = 0; i < inputEndpoints.length; i++)\n"
    "        {\n"
    "            if (inputEndpoints[i].endpointType == \"stream\")\n"
    "                performer.setInputFrames (inputEndpoints[i].handle,\n"
    "                                          inputFrames.slice (0, blockSize));\n"
    "        }\n"
    "\n"
    "        let runtime = performer.calculateRenderPerformance (blockSize, options.samplesToRender);\n"
    "        let framesPerSec = options.samplesToRender / runtime;\n"
    "        let utilisation = 100.0 * options.frequency / framesPerSec;\n"
    "\n"
    "        testSection.logMessage (\"Block size \" + blockSize + \", runtime \" + runtime + \", frames/sec = \"\n"
    "                                 + framesPerSec.toFixed(0) + \" utilisation = \" + utilisation.toFixed (2));\n"
    "        blockSize *= 2;\n"
    "    }\n"
    "\n"
    "    testSection.reportSuccess();\n"
    "}\n"
    "\n"
    "//==============================================================================\n"
    "/*\n"
    "    This test takes the filename of a .cmajorpatch and tries to build it, failing\n"
    "    if there are any errors. It doesn't use any code from the block in the test\n"
    "    file.\n"
    "\n"
    "    e.g.\n"
    "    ## testPatch (\"../../../cmajor/examples/patches/Freeverb/Freeverb.cmajorpatch\")\n"
    "*/\n"
    "function testPatch (file, expectedError)\n"
    "{\n"
    "    const testSection = getCurrentTestSection();\n"
    "    const absolutePath = testSection.getAbsolutePath (file);\n"
    "    const error = loadAndTestPatch (absolutePath, getDefaultEngineOptions(), 44100, 128);\n"
    "\n"
    "    let newErrorLine = getErrorReportString (error);\n"
    "\n"
    "    if (expectedError == null)\n"
    "    {\n"
    "        if (newErrorLine.length == 0)\n"
    "        {\n"
    "            testSection.reportSuccess();\n"
    "            return;\n"
    "        }\n"
    "\n"
    "        testSection.logMessage (error);\n"
    "        testSection.reportFail (\"unexpected error\");\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        newErrorLine = newErrorLine.replace (absolutePath, file);\n"
    "\n"
    "        if (expectedError == newErrorLine)\n"
    "        {\n"
    "            testSection.reportSuccess();\n"
    "            return;\n"
    "        }\n"
    "\n"
    "        if (expectedError.length == 0)\n"
    "        {\n"
    "            testSection.reportSuccess();\n"
    "            testSection.logMessage (\"Updating error text to '\" + newErrorLine + \"'\");\n"
    "            testSection.updateTestHeader (\"## testPatch (\\\"\" + file + \"\\\", \\\"\" + newErrorLine.replace (/\\\"/g, \"\\\\\\\"\") + \"\\\")\");\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            testSection.logMessage (error);\n"
    "            testSection.reportFail (\"error mismatch\");\n"
    "\n"
    "            testSection.logMessage (\"Expecting \" + expectedError);\n"
    "            testSection.logMessage (\"Got       \" + newErrorLine);\n"
    "        }\n"
    "    }\n"
    "}\n"
    "\n"
    "//==============================================================================\n"
    "/*\n"
    "    This test loads helper files containing input and output data that should\n"
    "    be fed into a processor. It can also run tests on a patch by specifying a patch\n"
    "    to build\n"
    "\n"
    "    e.g.\n"
    "    ## runScript ({ sampleRate:44100, blockSize:32, samplesToRender:1000, subDir:\"foo\" })\n"
    "    ## runScript ({ sampleRate:44100, blockSize:32, samplesToRender:1000, subDir:\"foo\", patch: \"path/to/patch.cmajorpatch\" })\n"
    "\n"
    "*/\n"
    "\n"
    "function runScript (options)\n"
    "{\n"
    "    let testSection = getCurrentTestSection();\n"
    "    let resetEvery = options.resetEvery;\n"
    "\n"
    "    if (options.subDir == null)\n"
    "        options.subDir = \".\";\n"
    "\n"
    "    if (options.maxDiffDb == null)\n"
    "        options.maxDiffDb = -100;\n"
    "\n"
    "    let timingInfo = {};\n"
    "\n"
    "    let engine = buildEngineWithLoadedProgram (testSection, options, timingInfo);\n"
    "\n"
    "    if (isError (engine, options))\n"
    "    {\n"
    "        testSection.reportFail (engine);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let inputEndpoints = engine.getInputEndpoints();\n"
    "    let outputEndpoints = engine.getOutputEndpoints();\n"
    "\n"
    "    let skipMissingInputs = options.skipMissingInputs || options.skipMissing;\n"
    "    let skipMissingOutputs = options.skipMissingOutputs || options.skipMissing;\n"
    "\n"
    "    for (let i = 0; i < inputEndpoints.length; i++)\n"
    "    {\n"
    "        inputEndpoints[i].handle = engine.getEndpointHandle (inputEndpoints[i].endpointID);\n"
    "\n"
    "        if (inputEndpoints[i].endpointType == \"stream\")\n"
    "        {\n"
    "            let expectedStreamFilename = options.subDir + \"/\" + inputEndpoints[i].endpointID + \".wav\";\n"
    "            let inputData = testSection.readStreamData (expectedStreamFilename);\n"
    "\n"
    "            if (isError (inputData))\n"
    "            {\n"
    "                if (! skipMissingInputs)\n"
    "                {\n"
    "                    testSection.reportFail (\"Failed to read input stream \" + expectedStreamFilename);\n"
    "                    return;\n"
    "                }\n"
    "\n"
    "                inputData.data = Array (options.samplesToRender);\n"
    "            }\n"
    "\n"
    "            inputEndpoints[i].frames = inputData;\n"
    "        }\n"
    "        else if (inputEndpoints[i].endpointType == \"value\")\n"
    "        {\n"
    "            let expectedStreamFilename = options.subDir + \"/\" + inputEndpoints[i].endpointID + \".json\";\n"
    "            let inputData = testSection.readEventData (expectedStreamFilename);\n"
    "\n"
    "            if (isError (inputData))\n"
    "            {\n"
    "                if (! skipMissingInputs)\n"
    "                {\n"
    "                    testSection.reportFail (\"Failed to read input value data \" + expectedStreamFilename);\n"
    "                    return;\n"
    "                }\n"
    "            }\n"
    "\n"
    "            if (! validateInputData (expectedStreamFilename, inputData, testSection, \"value\"))\n"
    "                return;\n"
    "\n"
    "            inputEndpoints[i].values = inputData;\n"
    "            inputEndpoints[i].nextValue = 0;\n"
    "        }\n"
    "        else if (inputEndpoints[i].endpointType == \"event\")\n"
    "        {\n"
    "            let expectedStreamFilename = options.subDir + \"/\" + inputEndpoints[i].endpointID + \".json\";\n"
    "            let inputData = testSection.readEventData (expectedStreamFilename);\n"
    "\n"
    "            if (isError (inputData))\n"
    "            {\n"
    "                if (inputEndpoints[i].purpose == \"midi in\")\n"
    "                {\n"
    "                    expectedStreamFilename = options.subDir + \"/\" + inputEndpoints[i].endpointID + \".mid\";\n"
    "                    inputData = testSection.readMidiData (expectedStreamFilename);\n"
    "                }\n"
    "\n"
    "                if (isError (inputData))\n"
    "                {\n"
    "                    if (! skipMissingInputs)\n"
    "                    {\n"
    "                        testSection.reportFail (\"Failed to read input event data \" + expectedStreamFilename);\n"
    "                        return;\n"
    "                    }\n"
    "                }\n"
    "            }\n"
    "\n"
    "            if (! validateInputData (expectedStreamFilename, inputData, testSection, \"event\"))\n"
    "                return;\n"
    "\n"
    "            inputEndpoints[i].events = inputData;\n"
    "            inputEndpoints[i].nextEvent = 0;\n"
    "        }\n"
    "    }\n"
    "\n"
    "    for (let i = 0; i < outputEndpoints.length; i++)\n"
    "    {\n"
    "        outputEndpoints[i].handle = engine.getEndpointHandle (outputEndpoints[i].endpointID);\n"
    "\n"
    "        if (outputEndpoints[i].endpointType == \"stream\")\n"
    "            outputEndpoints[i].frames = { \"sampleRate\": options.frequency, \"frameCount\": 0, \"data\": []};\n"
    "        else if (outputEndpoints[i].endpointType == \"value\")\n"
    "            outputEndpoints[i].values = [];\n"
    "        else if (outputEndpoints[i].endpointType == \"event\")\n"
    "            outputEndpoints[i].events = [];\n"
    "    }\n"
    "\n"
    "    timingInfo.linkTime = engine.link();\n"
    "\n"
    "    if (isError (timingInfo.linkTime, options))\n"
    "    {\n"
    "        reportFailOrUnsupported (testSection, timingInfo.linkTime);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    let performer = engine.createPerformer();\n"
    "\n"
    "    let outstandingSamples = options.samplesToRender;\n"
    "    let framesRendered = 0;\n"
    "\n"
    "    let eventsToApply = [];\n"
    "    let valuesToApply = [];\n"
    "\n"
    "    for (let i = 0; i < inputEndpoints.length; i++)\n"
    "    {\n"
    "        const input = inputEndpoints[i];\n"
    "\n"
    "        if (input.purpose == \"parameter\" && input.annotation.init !== undefined)\n"
    "        {\n"
    "            if (input.endpointType == \"event\")\n"
    "                eventsToApply.push ({ handle: input.handle,\n"
    "                                      event: input.annotation.init });\n"
    "            else\n"
    "                valuesToApply.push ({ handle: input.handle,\n"
    "                                      value: input.annotation.init,\n"
    "                                      frameCount: 0});\n"
    "        }\n"
    "    }\n"
    "\n"
    "    let framesTillReset = resetEvery;\n"
    "\n"
    "    while (outstandingSamples > 0)\n"
    "    {\n"
    "        let samplesThisBlock = (options.blockSize < outstandingSamples) ? options.blockSize : outstandingSamples;\n"
    "\n"
    "        if (framesTillReset != null)\n"
    "        {\n"
    "            if (framesTillReset == 0)\n"
    "            {\n"
    "                performer.reset();\n"
    "                framesTillReset = resetEvery;\n"
    "            }\n"
    "\n"
    "            if (samplesThisBlock > framesTillReset)\n"
    "                samplesThisBlock = framesTillReset;\n"
    "\n"
    "            framesTillReset -= samplesThisBlock;\n"
    "        }\n"
    "\n"
    "        for (let i = 0; i < inputEndpoints.length; i++)\n"
    "        {\n"
    "            if (inputEndpoints[i].endpointType == \"event\")\n"
    "            {\n"
    "                let arrayLength = inputEndpoints[i].events.length;\n"
    "\n"
    "                while (inputEndpoints[i].nextEvent < arrayLength && inputEndpoints[i].events[inputEndpoints[i].nextEvent].frameOffset == framesRendered)\n"
    "                {\n"
    "                    eventsToApply.push ({ handle: inputEndpoints[i].handle,\n"
    "                                          event: inputEndpoints[i].events[inputEndpoints[i].nextEvent].event });\n"
    "\n"
    "                    inputEndpoints[i].nextEvent++;\n"
    "                }\n"
    "\n"
    "                if (inputEndpoints[i].nextEvent < arrayLength)\n"
    "                {\n"
    "                    let framesTillNextEvent = inputEndpoints[i].events[inputEndpoints[i].nextEvent].frameOffset - framesRendered;\n"
    "\n"
    "                    if (framesTillNextEvent < samplesThisBlock)\n"
    "                        samplesThisBlock = framesTillNextEvent;\n"
    "                }\n"
    "            }\n"
    "            else if (inputEndpoints[i].endpointType == \"value\")\n"
    "            {\n"
    "                let arrayLength = inputEndpoints[i].values.length;\n"
    "\n"
    "                while (inputEndpoints[i].nextValue < arrayLength && inputEndpoints[i].values[inputEndpoints[i].nextValue].frameOffset == framesRendered)\n"
    "                {\n"
    "                    valuesToApply.push ({ handle: inputEndpoints[i].handle,\n"
    "                                          value: inputEndpoints[i].values[inputEndpoints[i].nextValue].value,\n"
    "                                          frameCount: inputEndpoints[i].values[inputEndpoints[i].nextValue].framesToReachValue});\n"
    "\n"
    "                    inputEndpoints[i].nextValue++;\n"
    "                }\n"
    "\n"
    "                if (inputEndpoints[i].nextValue < arrayLength)\n"
    "                {\n"
    "                    let framesTillNextValue = inputEndpoints[i].values[inputEndpoints[i].nextValue].frameOffset - framesRendered;\n"
    "\n"
    "                    if (framesTillNextValue < samplesThisBlock)\n"
    "                        samplesThisBlock = framesTillNextValue;\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "\n"
    "        performer.setBlockSize (samplesThisBlock);\n"
    "\n"
    "        for (let i = 0; i < eventsToApply.length; i++)\n"
    "            performer.addInputEvent (eventsToApply[i].handle, eventsToApply[i].event);\n"
    "\n"
    "        for (let i = 0; i < valuesToApply.length; i++)\n"
    "            performer.setInputValue (valuesToApply[i].handle, valuesToApply[i].value, valuesToApply[i].frameCount);\n"
    "\n"
    "        eventsToApply = [];\n"
    "        valuesToApply = [];\n"
    "\n"
    "        for (let i = 0; i < inputEndpoints.length; i++)\n"
    "        {\n"
    "            if (inputEndpoints[i].endpointType == \"stream\")\n"
    "            {\n"
    "                performer.setInputFrames (inputEndpoints[i].handle,\n"
    "                                          inputEndpoints[i].frames.data.slice (framesRendered,\n"
    "                                                                               framesRendered + samplesThisBlock));\n"
    "            }\n"
    "        }\n"
    "\n"
    "        performer.advance();\n"
    "\n"
    "        for (let i = 0; i < outputEndpoints.length; i++)\n"
    "        {\n"
    "            if (outputEndpoints[i].endpointType == \"stream\")\n"
    "            {\n"
    "                let outDataThisBlock = performer.getOutputFrames (outputEndpoints[i].handle);\n"
    "                Array.prototype.push.apply (outputEndpoints[i].frames.data, outDataThisBlock);\n"
    "                outputEndpoints[i].frames.frameCount += samplesThisBlock;\n"
    "            }\n"
    "            else if (outputEndpoints[i].endpointType == \"value\")\n"
    "            {\n"
    "                let outValue = performer.getOutputValue (outputEndpoints[i].handle);\n"
    "                let value = { frameOffset: framesRendered,\n"
    "                              value: outValue};\n"
    "                outputEndpoints[i].values.push (value);\n"
    "            }\n"
    "            else if (outputEndpoints[i].endpointType == \"event\")\n"
    "            {\n"
    "                let outEvents = performer.getOutputEvents (outputEndpoints[i].handle);\n"
    "\n"
    "                for (let n = 0; n < outEvents.length; n++)\n"
    "                {\n"
    "                    outEvents[n].frameOffset += framesRendered;\n"
    "                    outputEndpoints[i].events.push (outEvents[n]);\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "\n"
    "        outstandingSamples -= samplesThisBlock;\n"
    "        framesRendered += samplesThisBlock;\n"
    "    }\n"
    "\n"
    "    let overruns = performer.getXRuns();\n"
    "    let expectedOverruns = 0;\n"
    "\n"
    "    if (options.expectedOverruns)\n"
    "        expectedOverruns = options.expectedOverruns;\n"
    "\n"
    "    if (overruns != expectedOverruns)\n"
    "    {\n"
    "        testSection.reportFail (\"Expected \" + expectedOverruns + \" overruns, got \" + overruns);\n"
    "        return;\n"
    "    }\n"
    "\n"
    "    for (let i = 0; i < outputEndpoints.length; i++)\n"
    "    {\n"
    "        if (outputEndpoints[i].endpointType == \"stream\")\n"
    "        {\n"
    "            let expectedStreamFilename = options.subDir + \"/expectedOutput-\" + outputEndpoints[i].endpointID + \".wav\";\n"
    "\n"
    "            // testSection.logMessage (\"Got output data:\" + JSON.stringify (outputEndpoints[i].frames));\n"
    "\n"
    "            let expectedData = testSection.readStreamData (expectedStreamFilename);\n"
    "\n"
    "            if (isError (expectedData))\n"
    "            {\n"
    "                if (! skipMissingOutputs)\n"
    "                {\n"
    "                    testSection.logMessage (\"Can't find output file \" + expectedStreamFilename + \" - write it\");\n"
    "                    testSection.writeStreamData (expectedStreamFilename, outputEndpoints[i].frames);\n"
    "                }\n"
    "            }\n"
    "            else\n"
    "            {\n"
    "                // testSection.logMessage (\"Got expectedData data:\" + JSON.stringify (expectedData));\n"
    "\n"
    "                let result = streamDataComparison (outputEndpoints[i].frames, expectedData, options.maxDiffDb);\n"
    "\n"
    "                if (result != null)\n"
    "                {\n"
    "                    testSection.reportFail (outputEndpoints[i].endpointID + \": Comparison failed: \" + result);\n"
    "                    return;\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "        else if (outputEndpoints[i].endpointType == \"value\")\n"
    "        {\n"
    "            let expectedEventFilename = options.subDir + \"/expectedOutput-\" + outputEndpoints[i].endpointID + \".json\";\n"
    "            let expectedData = testSection.readEventData (expectedEventFilename);\n"
    "\n"
    "            if (isError (expectedData))\n"
    "            {\n"
    "                if (! skipMissingOutputs)\n"
    "                {\n"
    "                    testSection.logMessage (\"Can't find output file \" + expectedEventFilename + \" - write it\");\n"
    "                    testSection.writeEventData (expectedEventFilename, (outputEndpoints[i].values));\n"
    "                }\n"
    "            }\n"
    "            else\n"
    "            {\n"
    "                let result = eventDataComparison (testSection, outputEndpoints[i].values, expectedData, options.maxDiffDb);\n"
    "\n"
    "                if (result != null)\n"
    "                {\n"
    "                    testSection.reportFail (\"Comparison failed: \" + result);\n"
    "                    return;\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "        else if (outputEndpoints[i].endpointType == \"event\")\n"
    "        {\n"
    "            let expectedEventFilename = options.subDir + \"/expectedOutput-\" + outputEndpoints[i].endpointID + \".json\";\n"
    "            let expectedData = testSection.readEventData (expectedEventFilename);\n"
    "\n"
    "            if (isError (expectedData))\n"
    "            {\n"
    "                if (! skipMissingOutputs)\n"
    "                {\n"
    "                    testSection.logMessage (\"Can't find output file \" + expectedEventFilename + \" - write it\");\n"
    "                    testSection.writeEventData (expectedEventFilename, (outputEndpoints[i].events));\n"
    "                }\n"
    "            }\n"
    "            else\n"
    "            {\n"
    "                let result = eventDataComparison (testSection, outputEndpoints[i].events, expectedData, options.maxDiffDb);\n"
    "\n"
    "                if (result != null)\n"
    "                {\n"
    "                    testSection.reportFail (outputEndpoints[i].endpointID + \": Comparison failed: \" + result);\n"
    "                    return;\n"
    "                }\n"
    "            }\n"
    "        }\n"
    "\n"
    "    }\n"
    "\n"
    "    if (options.displayTimings)\n"
    "    {\n"
    "        let totalTime = timingInfo.loadTime  + timingInfo.linkTime;\n"
    "\n"
    "        if (timingInfo.parseTime != undefined)\n"
    "        {\n"
    "            totalTime += timingInfo.parseTime;\n"
    "            testSection.logMessage (\"Parse time: \" + Math.round (timingInfo.parseTime * 1000) + \" ms\");\n"
    "        }\n"
    "\n"
    "        testSection.logMessage (\"Load time : \" + Math.round (timingInfo.loadTime * 1000) + \" ms\");\n"
    "        testSection.logMessage (\"Link time : \" + Math.round (timingInfo.linkTime * 1000) + \" ms\");\n"
    "        testSection.logMessage (\"Total     : \" + Math.round (totalTime * 1000) + \" ms\");\n"
    "    }\n"
    "\n"
    "    testSection.reportSuccess();\n"
    "}\n"
    "\n"
    "\n"
    "//==============================================================================\n"
    "//==============================================================================\n"
    "//\n"
    "// The remainder of this file just consists of helper functions used by the code above\n"
    "//\n"
    "\n"
    "function buildEngineWithLoadedProgram (testSection, options, timingInfo, engine)\n"
    "{\n"
    "    if (options == undefined)\n"
    "        options = {};\n"
    "\n"
    "    if (engine == undefined)\n"
    "        engine = createEngine (options);\n"
    "\n"
    "    updateBuildSettings (engine, 44100, 1024, false, options);\n"
    "\n"
    "    let program;\n"
    "\n"
    "    if (options.patch != null)\n"
    "    {\n"
    "        let patch = new PatchManifest (testSection, new File (testSection.getAbsolutePath (options.patch)));\n"
    "\n"
    "        if (isError (patch.error))\n"
    "            return patch.error;\n"
    "\n"
    "        program = patch.createProgram();\n"
    "\n"
    "        if (isError (program))\n"
    "            return program;\n"
    "\n"
    "        timingInfo.loadTime = engine.load (program, patch.getExternals());\n"
    "\n"
    "        if (isError (timingInfo.loadTime))\n"
    "            return timingInfo.loadTime;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        program = new Program();\n"
    "\n"
    "        let sourceToParse = testSection.source + testSection.globalSource;\n"
    "\n"
    "        if (options.sourceTransformer != null)\n"
    "        {\n"
    "            let transformer = new SourceTransformer (testSection.getAbsolutePath (options.sourceTransformer));\n"
    "            let response = transformer.transform (\"test.cmajor\", sourceToParse);\n"
    "\n"
    "            if (isError (response))\n"
    "                return response;\n"
    "\n"
    "            sourceToParse = response;\n"
    "        }\n"
    "\n"
    "        let parseResult = program.parse (sourceToParse);\n"
    "\n"
    "        if (isError (parseResult, options))\n"
    "            return parseResult;\n"
    "\n"
    "        timingInfo.parseTime = parseResult;\n"
    "\n"
    "        let externalFilename = options.subDir + \"/externals.json\";\n"
    "        let externalData = testSection.readEventData (externalFilename);\n"
    "\n"
    "        timingInfo.loadTime = engine.load (program, externalData);\n"
    "\n"
    "        if (isError (timingInfo.loadTime, options))\n"
    "            return timingInfo.loadTime;\n"
    "    }\n"
    "\n"
    "    return engine;\n"
    "}\n"
    "\n"
    "\n"
    "function createEngine (options)\n"
    "{\n"
    "    let engineOptions = options?.engine;\n"
    "\n"
    "    if (engineOptions == null)\n"
    "        engineOptions = getDefaultEngineOptions();\n"
    "\n"
    "    return new Engine (engineOptions);\n"
    "}\n"
    "\n"
    "function updateBuildSettings (engine, defaultFrequency, defaultBlockSize, ignoreWarnings, options)\n"
    "{\n"
    "    let buildSettings = engine.getBuildSettings();\n"
    "\n"
    "    buildSettings.frequency      = defaultFrequency;\n"
    "    buildSettings.maxBlockSize   = defaultBlockSize;\n"
    "    buildSettings.ignoreWarnings = ignoreWarnings;\n"
    "\n"
    "    if (options)\n"
    "    {\n"
    "        if (options.maxFrequency !== undefined)       buildSettings.maxFrequency = options.maxFrequency;\n"
    "        if (options.frequency !== undefined)          buildSettings.frequency = options.frequency;\n"
    "        if (options.blockSize !== undefined)          buildSettings.blockSize = options.blockSize;\n"
    "        if (options.eventBufferSize !== undefined)    buildSettings.eventBufferSize = options.eventBufferSize;\n"
    "        if (options.maxStateSize !== undefined)       buildSettings.maxStateSize = options.maxStateSize;\n"
    "        if (options.maxStackSize !== undefined)       buildSettings.maxStackSize = options.maxStackSize;\n"
    "        if (options.sessionID !== undefined)          buildSettings.sessionID = options.sessionID;\n"
    "        if (options.optimisationLevel !== undefined)  buildSettings.optimisationLevel = options.optimisationLevel;\n"
    "        if (options.mainProcessor !== undefined)      buildSettings.mainProcessor = options.mainProcessor;\n"
    "    }\n"
    "\n"
    "    engine.setBuildSettings (buildSettings);\n"
    "}\n"
    "\n"
    "function getErrorReportString (error)\n"
    "{\n"
    "    if (! isErrorOrWarning (error))\n"
    "        return \"\";\n"
    "\n"
    "    if (Array.isArray (error))\n"
    "    {\n"
    "        let locationLines = [];\n"
    "\n"
    "        for (let i = 0; i < error.length; ++i)\n"
    "            locationLines.push (error[i].fullDescription);\n"
    "\n"
    "        return locationLines.join (\" //// \");\n"
    "    }\n"
    "\n"
    "    if (error.fullDescription != null)\n"
    "        return error.fullDescription;\n"
    "}\n"
    "\n"
    "// helper function to get a list of suitable boolean test functions\n"
    "// from a Program object\n"
    "function findTestFunctions (program)\n"
    "{\n"
    "    let result = [];\n"
    "    let syntaxTree = program.getSyntaxTree (\"tests\");\n"
    "\n"
    "    if (syntaxTree && syntaxTree.name == \"tests\")\n"
    "    {\n"
    "        for (let i = 0; i < syntaxTree.functions.length; ++i)\n"
    "        {\n"
    "            const func = syntaxTree.functions[i];\n"
    "\n"
    "            if (func.returnType.OBJECT == \"PrimitiveType\"\n"
    "                 && func.returnType.type == \"boolean\"\n"
    "                 && func.parameters.length == 0)\n"
    "            {\n"
    "                result.push (func.name);\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    return result;\n"
    "}\n"
    "\n"
    "function streamDataCompareValue (comparisonStats, expectedValue, actualValue, frame, channel)\n"
    "{\n"
    "    if (Math.abs (expectedValue) > comparisonStats.maxValue)\n"
    "        comparisonStats.maxValue = Math.abs (expectedValue);\n"
    "\n"
    "    let diff = Math.abs (expectedValue - actualValue);\n"
    "\n"
    "    if (diff > comparisonStats.maxDiff)\n"
    "    {\n"
    "        comparisonStats.maxDiff = diff;\n"
    "        comparisonStats.diffFrame = frame;\n"
    "        comparisonStats.diffChannel = channel;\n"
    "    }\n"
    "}\n"
    "\n"
    "function streamDataComparison (data, expectedData, maxDiffDb)\n"
    "{\n"
    "    if (data.sampleRate != expectedData.sampleRate)\n"
    "        return \"Sample rate mismatch - expected \" + expectedData.sampleRate + \", got \" + data.sampleRate;\n"
    "\n"
    "    if (data.frameCount != expectedData.frameCount)\n"
    "        return \"Frame count mismatch - expected \" + expectedData.frameCount + \", got \" + data.frameCount;\n"
    "\n"
    "    let comparisonStats = { \"maxDiff\": 0, \"maxValue\":0, \"diffFrame\":0, \"diffChannel\":0 };\n"
    "\n"
    "    for (let i = 0; i < expectedData.frameCount; i++)\n"
    "    {\n"
    "        let expectedFrame = expectedData.data[i];\n"
    "        let dataFrame = data.data[i];\n"
    "\n"
    "        // Convert all data to be array based to simplify vector<1> and primitive stream comparison\n"
    "        if (expectedFrame.length == null)\n"
    "            expectedFrame = [ expectedFrame ];\n"
    "\n"
    "        if (dataFrame.length == null)\n"
    "            dataFrame = [ dataFrame ];\n"
    "\n"
    "        if (expectedFrame.length != dataFrame.length)\n"
    "            return \"Channel count mimatch at frame \" + i + \", expected \" + expectedFrame.length + \", got \" + dataFrame.length;\n"
    "\n"
    "        for (let channel = 0; channel < expectedFrame.length; channel++)\n"
    "            streamDataCompareValue (comparisonStats, expectedFrame[channel], dataFrame[channel], i, channel);\n"
    "    }\n"
    "\n"
    "    let diffDb = 20.0 * Math.log10 (comparisonStats.maxDiff / comparisonStats.maxValue);\n"
    "\n"
    "    if (diffDb > maxDiffDb)\n"
    "        return \"Max db diff exceeded: diff of \" + diffDb + \" detected. maxDiffDb allowed:\" + maxDiffDb + \", maxDiff:\" + comparisonStats.maxDiff + \", maxValue:\" + comparisonStats.maxValue + \", diffFrame:\" + comparisonStats.diffFrame + \", diffChannel:\" + comparisonStats.diffChannel;\n"
    "\n"
    "    return null;\n"
    "}\n"
    "\n"
    "function removeObjNameValues (data)\n"
    "{\n"
    "    delete data[\"_objectName\"];\n"
    "\n"
    "    for (let key in data)\n"
    "        if (typeof data[key] == \"object\")\n"
    "            removeObjNameValues (data[key]);\n"
    "}\n"
    "\n"
    "// Check that expected and actual match. These values can be any javascript type. All values should\n"
    "// match, and float values should be within maxDiff of each other\n"
    "function compareValues (expected, actual, maxDiffDb)\n"
    "{\n"
    "    // Check for strict equality first (handles primitives and references)\n"
    "    if (expected === actual)\n"
    "        return true;\n"
    "\n"
    "    // Handle null/undefined cases\n"
    "    if (expected == null || actual == null)\n"
    "        return false;\n"
    "\n"
    "    // Get the types\n"
    "    const expectedType = typeof expected;\n"
    "    const actualType = typeof actual;\n"
    "\n"
    "    // Types must match\n"
    "    if (expectedType !== actualType)\n"
    "        return false;\n"
    "\n"
    "    // Handle numbers with tolerance\n"
    "    if (expectedType === \"number\")\n"
    "    {\n"
    "        if (! isFinite (expected) || ! isFinite (actual))\n"
    "            return expected === actual; // Handle NaN, Infinity cases with strict equality\n"
    "\n"
    "        let diffDb = 20.0 * Math.log10 (Math.abs (expected - actual));\n"
    "\n"
    "        return diffDb <= maxDiffDb;\n"
    "    }\n"
    "\n"
    "    // Handle strings\n"
    "    if (expectedType === \"string\")\n"
    "        return expected === actual;\n"
    "\n"
    "    // Handle arrays\n"
    "    if (Array.isArray (expected))\n"
    "    {\n"
    "        if (! Array.isArray (actual))\n"
    "            return false;\n"
    "\n"
    "        if (expected.length !== actual.length)\n"
    "            return false;\n"
    "\n"
    "        for (let i = 0; i < expected.length; i++)\n"
    "        {\n"
    "            if (! compareValues (expected[i], actual[i], maxDiffDb))\n"
    "                return false;\n"
    "        }\n"
    "\n"
    "        return true;\n"
    "    }\n"
    "\n"
    "    // Handle objects\n"
    "    if (expectedType === \"object\")\n"
    "    {\n"
    "        if (Array.isArray (actual))\n"
    "            return false;\n"
    "\n"
    "        const expectedKeys = Object.keys (expected);\n"
    "        const actualKeys = Object.keys (actual);\n"
    "\n"
    "        if (expectedKeys.length !== actualKeys.length)\n"
    "            return false;\n"
    "\n"
    "        for (let key of expectedKeys)\n"
    "        {\n"
    "            if (! (key in actual))\n"
    "                return false;\n"
    "\n"
    "            if (! compareValues (expected[key], actual[key], maxDiffDb))\n"
    "                return false;\n"
    "        }\n"
    "\n"
    "        return true;\n"
    "    }\n"
    "\n"
    "    // For other types (boolean, function, symbol), use strict equality\n"
    "    return expected === actual;\n"
    "}\n"
    "\n"
    "function eventDataComparison (testSection, data, expectedData, maxDiff)\n"
    "{\n"
    "    if (data.length != expectedData.length)\n"
    "        return \"Different number of events - expected \" + expectedData.length + \", got \" + data.length;\n"
    "\n"
    "    removeObjNameValues (data);\n"
    "    removeObjNameValues (expectedData);\n"
    "\n"
    "    for (let i = 0; i < data.length; i++)\n"
    "    {\n"
    "        if (data[i].frameOffset != expectedData[i].frameOffset)\n"
    "            return \"Event \" + i + \" has different frame offset - expected \" + expectedData[i].frameOffset + \", got \" + data[i].frameOffset;\n"
    "\n"
    "        // Handle support for value or event which occur in value/event json\n"
    "        if ('value' in data[i] || 'value' in expectedData[i])\n"
    "        {\n"
    "            if (! compareValues (expectedData[i].value, data[i].value, maxDiff))\n"
    "            {\n"
    "                var expectedValue = JSON.stringify (expectedData[i].value);\n"
    "                var dataValue = JSON.stringify (data[i].value);\n"
    "\n"
    "                return \"Event \" + i + \" has different value data - expected \" + expectedValue + \", got \" + dataValue + \" maxDiff:\" + maxDiff;\n"
    "            }\n"
    "        }\n"
    "\n"
    "        if ('event' in data[i] || 'event' in expectedData[i])\n"
    "        {\n"
    "            if (! compareValues (expectedData[i].event, data[i].event, maxDiff))\n"
    "            {\n"
    "                var expectedEvent = JSON.stringify (expectedData[i].event);\n"
    "                var dataEvent = JSON.stringify (data[i].event);\n"
    "\n"
    "                return \"Event \" + i + \" has different event data - expected \" + expectedEvent + \", got \" + dataEvent + \" maxDiff:\" + maxDiff;\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    return null;\n"
    "}\n"
    "\n"
    "// helper function to valid input data for event or value inputs\n"
    "function validateInputData (inputName, inputData, testSection, type)\n"
    "{\n"
    "    for (let i = 0; i < inputData.length; i++)\n"
    "    {\n"
    "        if (inputData[i].frameOffset == undefined)\n"
    "        {\n"
    "            testSection.reportFail (inputName + \": Failed validation, missing frameOffset attribute for item \" + i);\n"
    "            return false;\n"
    "        }\n"
    "\n"
    "        if (type == \"value\")\n"
    "        {\n"
    "            if (inputData[i].value == undefined)\n"
    "            {\n"
    "                testSection.reportFail (inputName + \": Failed validation, missing event attribute for item \" + i);\n"
    "                return false;\n"
    "            }\n"
    "\n"
    "            if (inputData[i].framesToReachValue == undefined)\n"
    "            {\n"
    "                testSection.reportFail (inputName + \": Failed validation, missing framesToReachValue attribute for item \" + i);\n"
    "                return false;\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    return true;\n"
    "}\n";
