//
//     ,ad888ba,                              88
//    d8"'    "8b
//   d8            88,dba,,adba,   ,aPP8A.A8  88     The Cmajor Toolkit
//   Y8,           88    88    88  88     88  88
//    Y8a.   .a8P  88    88    88  88,   ,88  88     (C)2024 Cmajor Software Ltd
//     '"Y888Y"'   88    88    88  '"8bbP"Y8  88     https://cmajor.dev
//                                           ,88
//                                        888P"
//
//  The Cmajor project is subject to commercial or open-source licensing.
//  You may use it under the terms of the GPLv3 (see www.gnu.org/licenses), or
//  visit https://cmajor.dev to learn about our commercial licence options.
//
//  CMAJOR IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER
//  EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE
//  DISCLAIMED.

#pragma once

#if CMAJ_ENABLE_CODEGEN_LLVM_WASM || CMAJ_ENABLE_CODEGEN_BINARYEN

#include "choc/text/choc_CodePrinter.h"
#include "choc/javascript/choc_javascript.h"
#include "../../transformations/cmaj_EventHandlerUtilities.h"
#include "../../transformations/cmaj_ValueStreamUtilities.h"
#include "../LLVM/cmaj_LLVM.h"


namespace cmaj::webassembly
{

struct SIMDMode
{
    SIMDMode (const choc::value::ValueView& options)
    {
        auto mode = options.isObject() ? options["SIMD"].toString() : std::string();
        allowSIMD = mode != "disable";
        allowNonSIMD = mode != "simd-only";
    }

    bool allowSIMD = true;
    bool allowNonSIMD = true;
};

struct JavascriptClassGenerator
{
    JavascriptClassGenerator (const AST::Program& p,
                              const BuildSettings& buildSettingsToUse,
                              std::string optionalMainClassName,
                              bool shouldUseBinaryen,
                              SIMDMode simdMode)
        : program (p),
          buildSettings (buildSettingsToUse),
          useBinaryen (shouldUseBinaryen),
          generateSIMD (simdMode.allowSIMD),
          generateNonSIMD (simdMode.allowNonSIMD),
          mainClassName (std::move (optionalMainClassName))
    {
    }

    std::string generate()
    {
        if (useBinaryen)
        {
           #if CMAJ_ENABLE_CODEGEN_BINARYEN
            hasNonSIMD = moduleNonSIMD.generate (program, buildSettings, true, false);
           #else
            CMAJ_ASSERT_FALSE;
           #endif
        }
        else
        {
           #if CMAJ_ENABLE_CODEGEN_LLVM_WASM
            if (generateSIMD)
                hasSIMD = moduleSIMD.generate (program, buildSettings, false, true);

            if (generateNonSIMD)
                hasNonSIMD = moduleNonSIMD.generate (program, buildSettings, false, false);
           #endif
        }

        if (hasNonSIMD || hasSIMD)
            return emitClass();

        return {};
    }

    std::string emitClass()
    {
        if (mainClassName.empty())
            mainClassName = choc::javascript::makeSafeIdentifier (std::string (program.getMainProcessor().name.get()));

        out.setTabSize (2);

        out << choc::text::replace (choc::text::trimStart (R"(
/***********************************************************************************
 *
 *   A Javascript/Webassembly implementation of the Cmajor processor 'FULL_PATH'.
 *
 *   This class was auto-generated by the Cmajor toolkit.
 *
 *   To use it, construct an instance of this class, and call `initialise()` to
 *   asynchronously prepare it for use. Once initialised, the class provides
 *   appropriate setter/getter methods for reading/writing data to its endpoints,
 *   and an `advance()` method to render the next block.
 *
 *   This roughly mirrors functionality of the cmajor Performer API - see the
 *   C++ API classes and Cmajor docs for more information about how this is used.
 */
class MAIN_CLASS
)"),                                "MAIN_CLASS", mainClassName,
                                    "FULL_PATH", program.getMainProcessor().getFullyQualifiedReadableName());

        {
            auto indent = out.createIndentWithBraces();

            emitConstructor();
            emitInitialiseFunction();
            emitAdvanceFunction();

            out << sectionBreak;

            emitSaveStateFunctions();

            emitInputEndpointListFunctions();
            emitOutputEndpointListFunctions();

            emitInputAccessorFunctions();
            emitOutputAccessorFunctions();

            out << sectionBreak
                << "// Code beyond this point is private internal implementation detail"
                << sectionBreak;

            for (auto& f : moduleSetupFns)
                f();

            emitStringHandleLookup();
        }

        out << blankLine;

        return out.toString();
    }

    struct GeneratedModule;

    //==============================================================================
    void emitConstructor()
    {
        out << choc::text::trimStart (R"(
/** After constructing one of these objects, call its
 *  initialise() method to prepare it for use.
 */
constructor()
)");
        auto indent2 = out.createIndentWithBraces();
    }

    void emitInitialiseFunction()
    {
        std::string callInitFn;

        if (hasSIMD && hasNonSIMD)
        {
            callInitFn = R"(
  const isSIMDAvailable = WebAssembly.validate (new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11]));

  if (isSIMDAvailable)
    await this._initialiseInternalSIMD (sessionID, frequency);
  else
    await this._initialiseInternalNonSIMD (sessionID, frequency);
)";
            moduleSetupFns.push_back ([this] { emitModuleSetupFunction ("SIMD", moduleSIMD); });
            moduleSetupFns.push_back ([this] { emitModuleSetupFunction ("NonSIMD", moduleNonSIMD); });

            moduleSetupFns.push_back ([this] { emitWasmBytesFunction ("_getWasmBytesSIMD", moduleSIMD); });
            moduleSetupFns.push_back ([this] { emitWasmBytesFunction ("_getWasmBytesNonSIMD", moduleNonSIMD); });
        }
        else
        {
            callInitFn = R"(
    await this._initialiseInternal (sessionID, frequency);
)";
            if (hasSIMD)
            {
                moduleSetupFns.push_back ([this] { emitModuleSetupFunction ({}, moduleSIMD); });
                moduleSetupFns.push_back ([this] { emitWasmBytesFunction ("_getWasmBytes", moduleSIMD); });
            }
            else
            {
                moduleSetupFns.push_back ([this] { emitModuleSetupFunction ({}, moduleNonSIMD); });
                moduleSetupFns.push_back ([this] { emitWasmBytesFunction ("_getWasmBytes", moduleNonSIMD); });
            }
        }

        out << sectionBreak
            << choc::text::replace (choc::text::trimStart (R"js(
/** Prepares this processor for use.
 *
 *  @param {number} sessionID - A unique integer ID which will be used for `processor.session`.
 *  @param {number} frequency - The frequency in Hz that the processor will be expected to run at.
 */
async initialise (sessionID, frequency)
{
  if (! ((sessionID ^ 0) > 1))
    throw new Error ("initialise() requires a valid non-zero session ID argument");

  if (! (frequency > 1))
    throw new Error ("initialise() requires a valid frequency argument");
  $CALL_INIT$
  return true;
}
)js"),
           "$CALL_INIT$", callInitFn);
    }

    void emitModuleSetupFunction (std::string suffix, GeneratedModule& module)
    {
        auto replaceModuleParams = [&] (std::string_view text)
        {
            return choc::text::replace (text,
                                        "$STATE_ADDRESS$", std::to_string (module.module.stateStructAddress),
                                        "$IO_ADDRESS$", std::to_string (module.module.ioStructAddress),
                                        "$SCRATCH_SPACE_ADDRESS$", std::to_string (module.module.scratchSpaceAddress),
                                        "$INITIAL_NUM_MEM_PAGES$", std::to_string (module.module.initialNumMemPages),
                                        "$STACK_TOP$", std::to_string (module.module.stackTop),
                                        "$SUFFIX$", suffix);
        };

        out << sectionBreak
            << choc::text::trimStart (R"(
/** @access private */
async _initialiseInternal)") << suffix << " (sessionID, frequency)" << newLine;
        {
            auto indent = out.createIndentWithBraces();

            out << replaceModuleParams (choc::text::trimStart (R"js(
this.stateAddress = $STATE_ADDRESS$;
this.scratchSpaceAddress = $SCRATCH_SPACE_ADDRESS$;

const memory = new WebAssembly.Memory ({ initial: $INITIAL_NUM_MEM_PAGES$ });
const stack = new WebAssembly.Global ({ value: "i32", mutable: true }, $STACK_TOP$);
const imports = {
  env: {
    __linear_memory: memory,
    __memory_base: 0,
    __stack_pointer: stack,
    __table_base: 0,
    memcpy:  (dst, src, len) => { this.byteMemory.copyWithin (dst, src, src + len); return dst; },
    memmove: (dst, src, len) => { this.byteMemory.copyWithin (dst, src, src + len); return dst; },
    memset:  (dst, value, len) => { this.byteMemory.fill (value, dst, dst + len); return dst; }
  },
};

const result = await WebAssembly.instantiate (this._getWasmBytes$SUFFIX$(), imports);
this.instance = result.instance;
const exports = this.instance.exports;
const memoryBuffer = exports.memory?.buffer || memory.buffer;
const memoryDataView = new DataView (memoryBuffer);
const byteMemory = new Uint8Array (memoryBuffer);
this.byteMemory = byteMemory;
this.memoryDataView = memoryDataView;

exports.initialise?.(this.stateAddress, this.scratchSpaceAddress, sessionID, frequency);

const advanceFn = exports.advanceBlock ? ((numFrames) => exports.advanceBlock ($STATE_ADDRESS$, $IO_ADDRESS$, numFrames))
                                       : (() => exports.advanceOneFrame ($STATE_ADDRESS$, $IO_ADDRESS$));

this.reset = () => {
   byteMemory.fill (0, $STATE_ADDRESS$, $IO_ADDRESS$);
   byteMemory.fill (0, $SCRATCH_SPACE_ADDRESS$, $SCRATCH_SPACE_ADDRESS$ + 4);
   exports.initialise?.(this.stateAddress, this.scratchSpaceAddress, sessionID, frequency);
};

this._advanceInternal = (numFrames) => )js"));

            {
                auto indent2 = out.createIndentWithBraces();

                for (auto& output : program.getMainProcessor().getOutputEndpoints (true))
                {
                    if (output->isStream())
                    {
                        auto details = findOriginalEndpointDetails (output);
                        auto info = getStreamInfo (module, details);

                        out << "byteMemory.fill (0, " << info.address << ", ";

                        if (buildSettings.getMaxBlockSize() == 1)
                            out << info.address + info.frameStride;
                        else
                            out << info.address << " + numFrames * " << info.frameStride;

                        out << ");" << newLine;
                    }
                }

                out << "advanceFn (numFrames);" << blankLine;
            }

            out << ";" << blankLine;

            for (auto& f : emitModuleSpecificFnSetup)
                f (module);

            emitPackerFunctions (module);
        }

        out << blankLine;
    }

    //==============================================================================
    void emitAdvanceFunction()
    {
        out << sectionBreak
            << choc::text::trimStart (R"(
/** Advances the processor by a number of frames.
 *
 *  Before calling `advance()` you should use the appropriate functions to
 *  push data and events into the processor's input endpoints. After calling
 *  `advance()` you can use its output endpoint access functions to read the
 *  results.
 *
 *  @param {number} numFrames - An integer number of frames to advance.
 *                              This must be greater than zero.
 */
advance (numFrames)
{
  this._advanceInternal (numFrames);
}
)");
    }

    //==============================================================================
    void emitSaveStateFunctions()
    {
        out << sectionBreak
            << choc::text::trim (R"(
/** Returns an object which encapsulates the state of the patch at this point.
 *  The state can be restored by passing this object to `restoreState()`.
 */
getState()
{
  return { memory: this.byteMemory.slice(0) };
}

/** Restores the patch to a state that was previously saved by a call to `getState()`
 */
restoreState (savedState)
{
  if (savedState?.memory && savedState.memory?.length === this.byteMemory.length)
    this.byteMemory.set (savedState.memory);
  else
    throw Error ("restoreState(): not a valid state object");
}
)") << blankLine;
    }

    //==============================================================================
    void emitListReturnFunction (std::string_view name, const choc::value::ValueView& list)
    {
        out << name << "()" << newLine;

        {
            auto indent = out.createIndentWithBraces();
            out << "return " << choc::json::toString (list, true) << ";" << newLine;
        }

        out << blankLine;
    }

    void emitInputEndpointListFunctions()
    {
        auto list = choc::value::createEmptyArray();

        for (auto& output : program.getMainProcessor().getOutputEndpoints (true))
        {
            auto details = findOriginalEndpointDetails (output);
            list.addArrayElement (details.toJSON (false));
        }

        out << choc::text::trimStart (R"(
/** Returns a list of the output endpoints that this processor exposes.
 *  @returns {Array}
 */
)");
        emitListReturnFunction ("getOutputEndpoints", list);
    }

    void emitOutputEndpointListFunctions()
    {
        auto list = choc::value::createEmptyArray();

        for (auto& input : program.getMainProcessor().getInputEndpoints (true))
        {
            auto details = findOriginalEndpointDetails (input);
            list.addArrayElement (details.toJSON (false));
        }

        out << choc::text::trimStart (R"(
/** Returns a list of the input endpoints that this processor exposes.
 *  @returns {Array}
 */
)");
        emitListReturnFunction ("getInputEndpoints", list);
    }

    void emitInputAccessorFunctions()
    {
        for (auto& input : program.getMainProcessor().getInputEndpoints (true))
        {
            auto details = findOriginalEndpointDetails (input);
            auto endpointID = details.endpointID.toString();

            if (details.isStream())
            {
                emitInputStreamWriteFunction (details);
            }
            else if (details.isValue())
            {
                auto type = getEndpointTypePair (input, 0);

                out << textWithEndpointReplacement (endpointID, R"(
/** Sets the value of endpoint "ENDPOINT".
 *  @param {Object} newValue - The new value, whose type will depend on the endpoint type
 *  @param {number} numFramesToReachValue - If this is non-zero and the type is scalar,
 *                                          this applies a ramp to reach the new value.
*/
setInputValue_ENDPOINT (newValue, numFramesToReachValue)
)");
                {
                    auto indent = out.createIndentWithBraces();
                    auto setValueFunctionName = AST::getSetValueFunctionName (input);

                    out << "this." << getPackerFunctionName (type) << " (this.scratchSpaceAddress, newValue);" << newLine;
                    out << "this.instance.exports." << setValueFunctionName << " (this.stateAddress, this.scratchSpaceAddress, numFramesToReachValue);" << newLine;
                }
            }
            else if (details.isEvent())
            {
                uint32_t index = 0;

                for (auto& eventType : input->getDataTypes())
                {
                    std::string params, paramVariable;

                    if (eventType->isVoid())
                    {
                        out << textWithEndpointReplacement (endpointID, R"(
/** Sends an event of type `void` to endpoint "ENDPOINT".
 */
)");
                        params = "()";
                        paramVariable = "undefined";
                    }
                    else
                    {
                        out << choc::text::replace (textWithEndpointReplacement (endpointID, R"(
/** Sends an event of type `$TYPE$` to endpoint "ENDPOINT".
 *  @param {$JSDOC_TYPE$} eventValue - The event to be added to the queue for this endpoint.
 */
)"),                        "$TYPE$", AST::print (eventType),
                            "$JSDOC_TYPE$", getJSDocType (eventType));

                        params = " (eventValue)";
                        paramVariable = "eventValue";
                    }

                    out << AST::getEventHandlerFunctionName (input, eventType, "sendInputEvent_") << params << newLine;

                    {
                        auto indent = out.createIndentWithBraces();

                        if (auto handlerFunction = AST::findEventHandlerFunction (input, eventType))
                        {
                            auto wasmEventHandlerFn = AST::getEventHandlerFunctionName (*handlerFunction);

                            if (isWASMPrimitive (eventType))
                            {
                                out << "this.instance.exports." << wasmEventHandlerFn << " (this.stateAddress, "
                                    << paramVariable << ");" << newLine;
                            }
                            else
                            {
                                auto type = TypePair { eventType.get(), details.dataTypes[index++] };
                                out << "this." << getPackerFunctionName (type) << " (this.scratchSpaceAddress, "
                                    << paramVariable << ");" << newLine
                                    << "this.instance.exports." << wasmEventHandlerFn
                                    << " (this.stateAddress, this.scratchSpaceAddress);" << newLine;
                            }
                        }
                    }

                    out << blankLine;
                }
            }

            out << blankLine;
        }
    }

    static std::string getJSDocType (const AST::TypeBase& t)
    {
        if (t.isPrimitiveInt() || t.isPrimitiveFloat()) return "number";
        if (t.isPrimitiveBool()) return "boolean";
        if (t.isPrimitiveString()) return "string";
        return "Object";
    }

    void emitOutputEventAccessorFunctions (const AST::EndpointDeclaration& output, const std::string& endpointID,
                                           const AST::StructType& stateStructType, uint32_t listIndex, uint32_t countIndex)
    {
        emitModuleSpecificFnSetup.push_back ([this, &output, endpointID, listIndex, countIndex, &stateStructType] (GeneratedModule& module)
        {
            auto countPackedOffset = module.stateStructChocType.getElementTypeAndOffset (countIndex).offset;
            auto countNativeBit = module.stateStructLayout->convertPackedByteToNativeBit (static_cast<uint32_t> (countPackedOffset));
            auto countType = createTypePair (module, *stateStructType.getAggregateElementType (countIndex));
            auto address = module.module.stateStructAddress + countNativeBit / 8;

            out << "this._unpackEventCountInternal_" << endpointID << " = () => { return "
                << getUnpackFunctionCall (module, countType, std::to_string (address))
                << "; };" << newLine;

            out << "this._resetEventCountInternal_" << endpointID << " = () => { memoryDataView.setInt32 ("
                << address << ", 0, true); };" << newLine;

            emitEventReadFunction (module, output, endpointID, stateStructType, listIndex);
        });

        out << textWithEndpointReplacement (endpointID, R"(
/** Returns the number of events available for endpoint "ENDPOINT" */
getOutputEventCount_ENDPOINT()
)");
        {
            auto indent = out.createIndentWithBraces();
            out << "return this._unpackEventCountInternal_" << endpointID << "();" << newLine;
        }

        out << blankLine
            << textWithEndpointReplacement (endpointID, R"(
/** Resets the FIFO for event endpoint "ENDPOINT" */
resetOutputEventCount_ENDPOINT()
)");
        {
            auto indent = out.createIndentWithBraces();
            out << "this._resetEventCountInternal_" << endpointID << "();" << newLine;
        }

        out << blankLine
            << textWithEndpointReplacement (endpointID, R"(
/** Returns one of the events from the FIFO for endpoint "ENDPOINT"
 *  @param {number} index - The index of the event to return
*/
getOutputEvent_ENDPOINT (index)
)");
        {
            auto indent = out.createIndentWithBraces();
            out << "return this._readEventInternal_" << endpointID << " (index);" << newLine;
        }
    }

    void emitEventReadFunction (GeneratedModule& module, const AST::EndpointDeclaration& output,
                                const std::string& endpointID, const AST::StructType& stateStructType, uint32_t listIndex)
    {
        out << blankLine
            << "this._readEventInternal_" << endpointID << " = (index) => ";

        {
            auto indent = out.createIndentWithBraces();

            auto listArrayTypeAndOffset = module.stateStructChocType.getElementTypeAndOffset (listIndex);
            auto& eventArrayType = listArrayTypeAndOffset.elementType;
            auto eventArrayPackedOffsetFromState = static_cast<uint32_t> (listArrayTypeAndOffset.offset);
            CMAJ_ASSERT (eventArrayType.isArray() && eventArrayType.getNumElements() > 1);

            auto eventEntryChocType = eventArrayType.getElementType();
            auto& eventEntryASTType = *stateStructType.getMemberType (listIndex).getAggregateElementType(0);
            auto eventEntryTypePair = TypePair { eventEntryASTType, eventEntryChocType };

            auto eventEntryPackedSize = static_cast<uint32_t> (eventEntryChocType.getValueDataSize());
            auto eventArray0NativeOffset = module.stateStructLayout->convertPackedByteToNativeByte (eventArrayPackedOffsetFromState);
            auto eventArray1NativeOffset = module.stateStructLayout->convertPackedByteToNativeByte (eventArrayPackedOffsetFromState + eventEntryPackedSize);
            auto eventArrayNativeStride = eventArray1NativeOffset - eventArray0NativeOffset;

            auto readEventMember = [&] (uint32_t index)
            {
                auto memberOffsetWithinState = eventArrayPackedOffsetFromState + static_cast<uint32_t> (eventEntryChocType.getElementTypeAndOffset (index).offset);
                auto nativeMemberOffset = module.stateStructLayout->convertPackedByteToNativeByte (memberOffsetWithinState) - eventArray0NativeOffset;

                auto type = index >= 2 ? getEndpointTypePair (output, index - 2)
                                        : eventEntryTypePair.getElementType (index);

                return getUnpackFunctionCall (module, type, addToValue ("eventAddress", nativeMemberOffset));
            };

            out << "const eventAddress = " << (module.module.stateStructAddress + eventArray0NativeOffset)
                << " + (" << eventArrayNativeStride << " * index);" << newLine
                << "const frame = " << readEventMember (0) << ";" << newLine;

            auto numEventTypes = eventEntryChocType.getNumElements() - 2;

            if (numEventTypes == 1)
            {
                out << "return { frame, typeIndex: 0, event: " << readEventMember (2) << " };" << newLine;
            }
            else
            {
                out << "const typeIndex = " << readEventMember (1) << ";" << blankLine;

                out << "switch (typeIndex)" << newLine;
                {
                    auto switchIndent = out.createIndentWithBraces();

                    for (uint32_t i = 0; i < numEventTypes; ++i)
                        out << "case " << i << ": return { frame, typeIndex, event: " << readEventMember (i + 2) << " };" << newLine;
                }

                out << blankLine;
                out << "return { frame, typeIndex, event: null };" << newLine;
            }
        }

        out << ";" << blankLine;
    }

    void emitOutputAccessorFunctions()
    {
        for (auto& output : program.getMainProcessor().getOutputEndpoints (true))
        {
            auto details = findOriginalEndpointDetails (output);
            auto endpointID = details.endpointID.toString();
            auto& stateStructType = AST::castToRef<AST::StructType> (hasSIMD ? *moduleSIMD.module.stateStructType
                                                                             : *moduleNonSIMD.module.stateStructType);

            if (details.isStream())
            {
                emitOutputStreamReadFunction (details);
            }
            else if (details.isValue())
            {
                auto index = stateStructType.indexOfMember (StreamUtilities::getValueEndpointStructMemberName (endpointID));
                CMAJ_ASSERT (index >= 0);

                emitModuleSpecificFnSetup.push_back ([this, endpointID, index, output] (GeneratedModule& module)
                {
                    auto valueTypeAndOffset = module.stateStructChocType.getElementTypeAndOffset (static_cast<uint32_t> (index));
                    auto packedOffsetInState = static_cast<uint32_t> (valueTypeAndOffset.offset);
                    auto nativeOffsetInState = module.stateStructLayout->convertPackedByteToNativeByte (packedOffsetInState);
                    auto typePair = getEndpointTypePair (output, 0);

                    out << "this._unpackValueInternal_" << endpointID << " = () => { return "
                        << getUnpackFunctionCall (module, typePair, std::to_string (module.module.stateStructAddress + nativeOffsetInState))
                        << "; };" << newLine;
                });

                out << textWithEndpointReplacement (endpointID, R"(
/** Returns the current value of endpoint "ENDPOINT" */
getOutputValue_ENDPOINT()
)");
                {
                    auto indent = out.createIndentWithBraces();
                    out << "return this._unpackValueInternal_" << endpointID << "();" << newLine;
                }
            }
            else if (details.isEvent())
            {
                auto countIndex = stateStructType.indexOfMember (EventHandlerUtilities::getEventCountStateMemberName (endpointID));
                auto listIndex  = stateStructType.indexOfMember (endpointID);
                CMAJ_ASSERT (countIndex >= 0 && listIndex >= 0);

                emitOutputEventAccessorFunctions (output, endpointID, stateStructType,
                                                  static_cast<uint32_t> (listIndex),
                                                  static_cast<uint32_t> (countIndex));
            }

            out << blankLine;
        }
    }

    void emitOutputStreamReadFunction (EndpointDetails& details)
    {
        emitModuleSpecificFnSetup.push_back ([this, details] (GeneratedModule& module)
        {
            auto info = getStreamInfo (module, details);

            auto write = [&] (std::string_view code)
            {
                out << choc::text::replace (choc::text::trim (code),
                                            "$UNPACK_FRAME$", getUnpackFunctionCall (module, info.frameType, "$ADDRESS$ + frameIndex * $FRAME_STRIDE$"),
                                            "$UNPACK_SAMPLE$", getUnpackFunctionCall (module, info.sampleType, "source + $SAMPLE_STRIDE$ * channel"),
                                            "$ADDRESS$", std::to_string (info.address),
                                            "$SRC_CHANS$", std::to_string (info.numChannels),
                                            "$MAX_NUM_FRAMES$", std::to_string (buildSettings.getMaxBlockSize()),
                                            "$FRAME_STRIDE$", std::to_string (info.frameStride),
                                            "$SAMPLE_STRIDE$", std::to_string (info.sampleStride),
                                            "$ENDPOINT$", info.endpointID)
                    << blankLine;
            };

            write (R"(
this._getOutputFrameInternal_$ENDPOINT$ = (frameIndex) => { return $UNPACK_FRAME$; };

this._getOutputFramesInternal_$ENDPOINT$ = (destChannelArrays, maxNumFramesToRead, destChannel) => {
  if (maxNumFramesToRead > $MAX_NUM_FRAMES$)
    maxNumFramesToRead = $MAX_NUM_FRAMES$;

  const channelsToCopy = Math.min ($SRC_CHANS$, destChannelArrays.length - destChannel);
  let source = $ADDRESS$;

  for (let frame = 0; frame < maxNumFramesToRead; ++frame)
  {
    for (let channel = 0; channel < channelsToCopy; ++channel)
      destChannelArrays[destChannel + channel][frame] = $UNPACK_SAMPLE$;

    source += $FRAME_STRIDE$;
  }
};
)");
        });

        out << textWithEndpointReplacement (details.endpointID.toString(), R"(
/** Returns a frame from the output stream "ENDPOINT"
 *
 * @param {number} frameIndex - the index of the frame to fetch
 */
getOutputFrame_ENDPOINT (frameIndex)
)");
        {
            auto indent = out.createIndentWithBraces();
            out << "return this._getOutputFrameInternal_" << details.endpointID.toString() << " (frameIndex);" << newLine;
        }

        out << blankLine
            << textWithEndpointReplacement (details.endpointID.toString(), R"(
/** Copies frames from the output stream "ENDPOINT" into a destination array.
 *
 * @param {Array} destChannelArrays   - An array of arrays (one per channel) into
 *                                      which the samples will be copied
 * @param {number} maxNumFramesToRead - The maximum number of frames to copy
 * @param {number} destChannel        - The channel to start writing from
 */
getOutputFrames_ENDPOINT (destChannelArrays, maxNumFramesToRead, destChannel)
)");
        {
            auto indent = out.createIndentWithBraces();
            out << "this._getOutputFramesInternal_" << details.endpointID.toString()
                << " (destChannelArrays, maxNumFramesToRead, destChannel);" << newLine;
        }

        out << blankLine;
    }

    void emitInputStreamWriteFunction (EndpointDetails& details)
    {
        emitModuleSpecificFnSetup.push_back ([this, details] (GeneratedModule& module)
        {
            auto info = getStreamInfo (module, details);

            auto write = [&] (std::string_view code)
            {
                out << choc::text::replace (choc::text::trim (code),
                                            "$ADDRESS$", std::to_string (info.address),
                                            "$DST_CHANS$", std::to_string (info.numChannels),
                                            "$MAX_NUM_FRAMES$", std::to_string (buildSettings.getMaxBlockSize()),
                                            "$PACK_SAMPLE$", std::string ("this.") + getPackerFunctionName (info.sampleType),
                                            "$FRAME_STRIDE$", std::to_string (info.frameStride),
                                            "$SAMPLE_STRIDE$", std::to_string (info.sampleStride),
                                            "$ENDPOINT$", info.endpointID)
                    << blankLine;
            };

            write (R"(
this._setInputFramesInternal_$ENDPOINT$ = (sourceChannelArrays, numFramesToWrite, sourceChannel) => {
  try
  {
    if (numFramesToWrite > $MAX_NUM_FRAMES$)
      numFramesToWrite = $MAX_NUM_FRAMES$;

    const channelsToCopy = Math.min ($DST_CHANS$, sourceChannelArrays.length - sourceChannel);
    let dest = $ADDRESS$;

    for (let frame = 0; frame < numFramesToWrite; ++frame)
    {
      for (let channel = 0; channel < channelsToCopy; ++channel)
        $PACK_SAMPLE$ (dest + $SAMPLE_STRIDE$ * channel, sourceChannelArrays[sourceChannel + channel][frame]);

      dest += $FRAME_STRIDE$;
    }
  }
  catch (error)
  {
    // Sometimes, often at startup, Web Audio provides an empty buffer - causing TypeError on attempt to dereference
    if (! (error instanceof TypeError))
      throw (error);
  }
};
)");
        });

        out << textWithEndpointReplacement (details.endpointID.toString(), R"(
/** Stores frames for the input to endpoint "ENDPOINT"
 *
 * @param {Array} sourceChannelArrays - An array of channel arrays to read
 * @param {number} numFramesToWrite   - The number of frames to copy
 * @param {number} sourceChannel      - The source channel to copy from
 */
setInputStreamFrames_ENDPOINT (sourceChannelArrays, numFramesToWrite, sourceChannel)
)");
        {
            auto indent = out.createIndentWithBraces();
            out << "this._setInputFramesInternal_" << details.endpointID.toString()
                << " (sourceChannelArrays, numFramesToWrite, sourceChannel);" << newLine;
        }
    }

    void emitWasmBytesFunction (std::string_view functionName, GeneratedModule& module)
    {
        out << blankLine
            << "/** @access private */" << newLine
            << functionName << "()" << newLine;
        {
            auto indent = out.createIndentWithBraces();

            std::string currentLine = "return new Uint8Array([";
            out << currentLine;

            for (auto byte : module.module.binaryWASMData)
            {
                if (currentLine.length() > 200)
                {
                    currentLine = {};
                    out << newLine << "  ";
                }

                auto s = std::to_string (static_cast<uint8_t> (byte)) + ",";
                currentLine += s;
                out << s;
            }

            out << "]);" << newLine;
        }

        out << blankLine;
    }

    void emitPackerFunctions (GeneratedModule& module)
    {
        for (auto& packer : packerFunctions)
            writeTypePackerFunction (module, packer.type);

        for (auto& unpacker : unpackerFunctions)
            writeTypeUnpackerFunction (module, unpacker.type);
    }

    void emitStringHandleLookup()
    {
        const auto& strings = hasSIMD ? moduleSIMD.module.stringDictionary.strings
                                      : moduleNonSIMD.module.stringDictionary.strings;

        CMAJ_ASSERT (! (hasSIMD && hasNonSIMD) || strings == moduleNonSIMD.module.stringDictionary.strings);

        if (strings.empty())
            return;

        out << "/** @access private */" << newLine
            << "_getStringForHandle (handle)" << newLine;
        {
            auto indent = out.createIndentWithBraces();

            out << "switch (handle)" << newLine;
            {
                auto indent2 = out.createIndentWithBraces();

                auto stringData = strings.data();
                auto totalLength = strings.size();
                size_t offset = 0;

                for (;;)
                {
                    auto len = strnlen (stringData + offset, totalLength - offset);
                    auto s = std::string_view (stringData + offset, len);

                    out << "case " << offset + 1 << ": return " << choc::json::getEscapedQuotedString (s) << ";" << newLine;

                    offset += len + 1;

                    if (len == 0 || offset >= totalLength)
                        break;
                }
            }
        }

        out << blankLine;
    }

    //==============================================================================
    [[nodiscard]] static std::string textWithEndpointReplacement (std::string_view endpointID, std::string_view text)
    {
        return choc::text::replace (choc::text::trimStart (text), "ENDPOINT", endpointID);
    }

    // We can't create a new EndointDetails from an endpoint, because any types will have had
    // their multidimensional arrays flattened
    EndpointDetails findOriginalEndpointDetails (const AST::EndpointDeclaration& endpoint) const
    {
        for (auto& e : program.endpointList.inputEndpointDetails)
            if (e.endpointID == endpoint.getEndpointID())
                return e;

        for (auto& e : program.endpointList.outputEndpointDetails)
            if (e.endpointID == endpoint.getEndpointID())
                return e;

        CMAJ_ASSERT_FALSE;
        return {};
    }

    struct TypePair
    {
        ptr<const AST::TypeBase> astType;
        choc::value::Type chocType;

        TypePair getElementType (uint32_t index) const
        {
            if (chocType.isObject())
                return { *astType->getAggregateElementType (index),
                         chocType.getObjectMember (index).type };

            return { *astType->getAggregateElementType (index),
                     chocType.getElementType() };
        }
    };

    TypePair getEndpointTypePair (const AST::EndpointDeclaration& endpoint, size_t index) const
    {
        return { AST::castToTypeBaseRef (endpoint.dataTypes[index]),
                 findOriginalEndpointDetails (endpoint).dataTypes[index] };
    }

    static TypePair createTypePair (GeneratedModule& module, const AST::TypeBase& type)
    {
        return { type, module.module.getChocType (type) };
    }

    struct StreamInfo
    {
        std::string endpointID;
        uint32_t address, numChannels, frameStride, sampleStride;
        TypePair frameType, sampleType;
    };

    StreamInfo getStreamInfo (GeneratedModule& module, const EndpointDetails& details)
    {
        StreamInfo info;
        info.endpointID = details.endpointID.toString();

        const auto& ioStructType = AST::castToRef<AST::StructType> (module.module.ioStructType);
        auto index = ioStructType.indexOfMember (info.endpointID);
        CMAJ_ASSERT (index >= 0);

        auto memberTypeAndOffset = module.ioStructChocType.getElementTypeAndOffset (static_cast<uint32_t> (index));
        auto typePair = TypePair { ioStructType.getMemberType (static_cast<uint32_t> (index)), memberTypeAndOffset.elementType };

        auto packedOffsetInState = static_cast<uint32_t> (memberTypeAndOffset.offset);
        auto nativeOffsetInState = module.ioStructLayout->convertPackedByteToNativeByte (packedOffsetInState);
        info.address = module.module.ioStructAddress + nativeOffsetInState;

        if (buildSettings.getMaxBlockSize() == 1)
        {
            info.frameType = typePair;
            auto packedStride = static_cast<uint32_t> (typePair.chocType.getValueDataSize());
            info.frameStride = module.ioStructLayout->convertPackedByteToNativeByte (packedOffsetInState + packedStride) - nativeOffsetInState;
        }
        else
        {
            info.frameType = typePair.getElementType (0);
            auto packedStride = static_cast<uint32_t> (typePair.chocType.getElementTypeAndOffset (1).offset);
            info.frameStride = module.ioStructLayout->convertPackedByteToNativeByte (packedOffsetInState + packedStride) - nativeOffsetInState;
        }

        if (info.frameType.chocType.isVector())
        {
            info.numChannels = info.frameType.chocType.getNumElements();
            info.sampleType = info.frameType.getElementType (0);

            auto packedStride = static_cast<uint32_t> (info.sampleType.chocType.getValueDataSize());
            info.sampleStride = module.ioStructLayout->convertPackedByteToNativeByte (packedOffsetInState + packedStride) - nativeOffsetInState;
        }
        else
        {
            info.numChannels = 1;
            info.sampleType = info.frameType;
            info.sampleStride = info.frameStride;
        }

        return info;
    }

    static std::string addToValue (const std::string& value, size_t valueToAdd)
    {
        return valueToAdd == 0 ? value : (value + " + " + std::to_string (valueToAdd));
    }

    //==============================================================================
    std::string getPackerFunctionName (const TypePair& type)
    {
        auto name = "_pack_" + type.chocType.getSignature (true);

        for (auto& f : packerFunctions)
            if (f.name == name)
                return name;

        packerFunctions.push_back ({ type, name });
        return name;
    }

    std::string getUnpackFunctionCall (GeneratedModule& module, const TypePair& type, const std::string& address)
    {
        if (type.astType->isPrimitiveInt() || type.astType->isPrimitiveFloat())
            return getTypeUnpacker (module, *type.astType, type.chocType, address, 0);

        return "this." + getUnpackerFunctionName (type) + " (" + address + ")";
    }

    std::string getUnpackerFunctionName (const TypePair& type)
    {
        auto name = "_unpack_" + type.chocType.getSignature (true);

        for (auto& f : unpackerFunctions)
            if (f.name == name)
                return name;

        unpackerFunctions.push_back ({ type, name });
        return name;
    }

    void writeTypePackerFunction (GeneratedModule& module, const TypePair& type)
    {
        out << "this." << getPackerFunctionName (type) << " = (address, newValue) => ";
        {
            auto indent = out.createIndentWithBraces();
            writeTypePacker (module, *type.astType, type.chocType, "address", 0, "newValue");
        }

        out << ";" << blankLine;
    }

    void writeTypeUnpackerFunction (GeneratedModule& module, const TypePair& type)
    {
        out << "this." << getUnpackerFunctionName (type) << " = (address) => ";
        {
            auto indent = out.createIndentWithBraces();
            out << "return " << getTypeUnpacker (module, *type.astType, type.chocType, "address", 0) << ";" << newLine;
        }

        out << ";" << blankLine;
    }

    void writeTypePacker (GeneratedModule& module, const AST::TypeBase& baseType, const choc::value::Type& type,
                          const std::string& baseAddressVariable, uint32_t packedOffsetFromBase, const std::string& newValue)
    {
        auto writePrimitivePacker = [&] (std::string_view typeName, const std::string& v)
        {
            auto nativeOffset = module.module.nativeTypeLayouts.get (baseType)->convertPackedByteToNativeByte (packedOffsetFromBase);
            out << "memoryDataView.set" << typeName << " (" << addToValue (baseAddressVariable, nativeOffset)
                << ", " << v << ", " << (littleEndianPacking ? "true" : "false") << ");" << newLine;
        };

        if (type.isInt32())     return writePrimitivePacker ("Int32",    newValue);
        if (type.isFloat32())   return writePrimitivePacker ("Float32",  newValue);
        if (type.isInt64())     return writePrimitivePacker ("BigInt64", newValue);
        if (type.isFloat64())   return writePrimitivePacker ("Float64",  newValue);

        if (type.isBool())
        {
            auto nativeBit = module.module.nativeTypeLayouts.get (baseType)->convertPackedByteToNativeBit (packedOffsetFromBase);
            auto address = addToValue (baseAddressVariable, nativeBit / 8);
            auto onMask = static_cast<uint8_t> (1u << (nativeBit & 7));
            uint8_t offMask = ~onMask;

            out << "memoryDataView.setUint8 (" << address << ", " << newValue
                << " ? (" << onMask << " | memoryDataView.getUint8(" << address << "))"
                << " : (" << offMask << " & memoryDataView.getUint8(" << address << ")));" << newLine;

            return;
        }

        if (type.isArray() || type.isVector() || type.isObject())
        {
            for (uint32_t i = 0; i < type.getNumElements(); ++i)
            {
                auto element = type.getElementTypeAndOffset (i);
                auto indexSuffix = type.isObject() ? ("." + std::string (type.getObjectMember (i).name))
                                                            : ("[" + std::to_string (i) + "]");

                writeTypePacker (module, baseType, element.elementType, baseAddressVariable,
                                 packedOffsetFromBase + static_cast<uint32_t> (element.offset),
                                 newValue + indexSuffix);
            }

            return;
        }

        CMAJ_ASSERT_FALSE;
    }

    std::string getTypeUnpacker (GeneratedModule& module, const AST::TypeBase& baseType, const choc::value::Type& type,
                                 const std::string& baseAddressVariable, uint32_t packedOffsetFromBase)
    {
        auto getPrimitiveUnpacker = [&] (const std::string& typeName)
        {
            auto nativeOffset = module.module.nativeTypeLayouts.get (baseType)->convertPackedByteToNativeByte (packedOffsetFromBase);

            return "memoryDataView.get" + typeName + " (" + addToValue (baseAddressVariable, nativeOffset)
                     + (littleEndianPacking ? ", true)"
                                            : ", false)");
        };

        if (type.isInt32())     return getPrimitiveUnpacker ("Int32");
        if (type.isString())    return getPrimitiveUnpacker ("Int32");
        if (type.isFloat32())   return getPrimitiveUnpacker ("Float32");
        if (type.isInt64())     return getPrimitiveUnpacker ("BigInt64");
        if (type.isFloat64())   return getPrimitiveUnpacker ("Float64");

        if (type.isBool())
        {
            auto nativeBit = module.module.nativeTypeLayouts.get (baseType)->convertPackedByteToNativeBit (packedOffsetFromBase);
            auto address = addToValue (baseAddressVariable, nativeBit / 8);
            auto mask = static_cast<uint8_t> (1u << (nativeBit & 7));

            return "((memoryDataView.getUint8 (" + address + ") & " + std::to_string (mask) + ") !== 0)";
        }

        if (type.isArray() || type.isVector())
        {
            std::string s = "[";
            auto numElements = type.getNumElements();

            for (uint32_t i = 0; i < numElements; ++i)
            {
                if (i != 0)
                    s += ", ";

                auto element = type.getElementTypeAndOffset (i);
                s += getTypeUnpacker (module, baseType, element.elementType, baseAddressVariable,
                                      packedOffsetFromBase + static_cast<uint32_t> (element.offset));
            }

            return s + "]";
        }

        if (type.isObject())
        {
            std::string s = "{ ";
            auto numElements = type.getNumElements();

            for (uint32_t i = 0; i < numElements; ++i)
            {
                if (i != 0)
                    s += ", ";

                auto member = type.getObjectMember (i);
                auto memberOffset = static_cast<uint32_t> (type.getElementTypeAndOffset (i).offset);

                s += choc::json::getEscapedQuotedString (member.name)
                       + ": " + getTypeUnpacker (module, baseType, member.type, baseAddressVariable, packedOffsetFromBase + memberOffset);
            }

            return s + " }";
        }

        CMAJ_ASSERT_FALSE;
    }

    static bool isWASMPrimitive (const AST::TypeBase& type)
    {
        if (auto p = type.skipConstAndRefModifiers().getAsPrimitiveType())
            return p->isVoid() || p->isPrimitiveBool() || p->isPrimitiveInt()
                    || p->isPrimitiveFloat() || p->isPrimitiveString();

        return type.isEnum();
    }

    static constexpr bool littleEndianPacking = true;

    const AST::Program& program;
    const BuildSettings& buildSettings;
    const bool useBinaryen, generateSIMD, generateNonSIMD;
    std::string mainClassName;

    struct GeneratedModule
    {
        bool generate (const AST::Program& p, const BuildSettings& settings, bool binaryen, bool useSIMD)
        {
            (void) useSIMD;

            if (binaryen)
            {
               #if CMAJ_ENABLE_CODEGEN_BINARYEN
                module = binaryen::generateWebAssembly (p, settings);
               #else
                CMAJ_ASSERT_FALSE;
               #endif
            }
            else
            {
               #if CMAJ_ENABLE_CODEGEN_LLVM_WASM
                module = llvm::generateWebAssembly (p, settings, useSIMD);
               #endif
            }

            if (module.binaryWASMData.empty())
                return false;

            stateStructLayout = module.nativeTypeLayouts.get (*module.stateStructType);
            ioStructLayout = module.nativeTypeLayouts.get (*module.ioStructType);

            stateStructChocType = module.getChocType (*module.stateStructType);
            ioStructChocType = module.getChocType (*module.ioStructType);
            return true;
        }

        WebAssemblyModule module;
        ptr<const NativeTypeLayout> stateStructLayout, ioStructLayout;
        choc::value::Type stateStructChocType, ioStructChocType;
    };

    GeneratedModule moduleSIMD, moduleNonSIMD;
    bool hasSIMD = false, hasNonSIMD = false;
    std::vector<std::function<void(GeneratedModule&)>> emitModuleSpecificFnSetup;
    std::vector<std::function<void()>> moduleSetupFns;

    choc::text::CodePrinter out;

    struct PackingFunction
    {
        TypePair type;
        std::string name;
    };

    std::vector<PackingFunction> packerFunctions, unpackerFunctions;

    static constexpr choc::text::CodePrinter::NewLine newLine = {};
    static constexpr choc::text::CodePrinter::BlankLine blankLine = {};
    static constexpr choc::text::CodePrinter::SectionBreak sectionBreak = {};
};

}

#endif
