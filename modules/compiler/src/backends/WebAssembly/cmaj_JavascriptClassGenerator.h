//
//     ,ad888ba,                              88
//    d8"'    "8b
//   d8            88,dba,,adba,   ,aPP8A.A8  88     The Cmajor Toolkit
//   Y8,           88    88    88  88     88  88
//    Y8a.   .a8P  88    88    88  88,   ,88  88     (C)2024 Cmajor Software Ltd
//     '"Y888Y"'   88    88    88  '"8bbP"Y8  88     https://cmajor.dev
//                                           ,88
//                                        888P"
//
//  The Cmajor project is subject to commercial or open-source licensing.
//  You may use it under the terms of the GPLv3 (see www.gnu.org/licenses), or
//  visit https://cmajor.dev to learn about our commercial licence options.
//
//  CMAJOR IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER
//  EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE
//  DISCLAIMED.

#pragma once

#if CMAJ_ENABLE_CODEGEN_LLVM_WASM || CMAJ_ENABLE_CODEGEN_BINARYEN

#include "choc/text/choc_CodePrinter.h"
#include "choc/javascript/choc_javascript.h"
#include "../../transformations/cmaj_EventHandlerUtilities.h"
#include "../../transformations/cmaj_ValueStreamUtilities.h"
#include "../LLVM/cmaj_LLVM.h"


namespace cmaj::webassembly
{

struct JavascriptClassGenerator
{
    JavascriptClassGenerator (const AST::Program& p,
                              const BuildSettings& buildSettingsToUse,
                              std::string optionalMainClassName,
                              bool shouldUseBinaryen)
        : program (p),
          buildSettings (buildSettingsToUse),
          useBinaryen (shouldUseBinaryen),
          mainClassName (std::move (optionalMainClassName))
    {
    }

    std::string generate()
    {
        if (useBinaryen)
        {
           #if CMAJ_ENABLE_CODEGEN_BINARYEN
            module = binaryen::generateWebAssembly (program, buildSettings);
           #else
            CMAJ_ASSERT_FALSE;
           #endif
        }
        else
        {
           #if CMAJ_ENABLE_CODEGEN_LLVM_WASM
            module = llvm::generateWebAssembly (program, buildSettings);
           #endif
        }

        if (module.binaryWASMData.empty())
            return {};

        stateStructLayout = module.nativeTypeLayouts.get (*module.stateStructType);
        ioStructLayout = module.nativeTypeLayouts.get (*module.ioStructType);

        stateStructChocType = module.getChocType (*module.stateStructType);
        ioStructChocType = module.getChocType (*module.ioStructType);

        return emitClass();
    }

    std::string emitClass()
    {
        if (mainClassName.empty())
            mainClassName = choc::javascript::makeSafeIdentifier (std::string (program.getMainProcessor().name.get()));

        out.setTabSize (2);

        out << choc::text::replace (choc::text::trimStart (R"(
/***********************************************************************************
 *
 *   A Javascript/Webassembly implementation of the Cmajor processor 'FULL_PATH'.
 *
 *   This class was auto-generated by the Cmajor toolkit.
 *
 *   To use it, construct an instance of this class, and call `initialise()` to
 *   asynchronously prepare it for use. Once initialised, the class provides
 *   appropriate setter/getter methods for reading/writing data to its endpoints,
 *   and an `advance()` method to render the next block.
 *
 *   This roughly mirrors functionality of the cmajor Performer API - see the
 *   C++ API classes and Cmajor docs for more information about how this is used.
 */
class MAIN_CLASS
)"),                                "MAIN_CLASS", mainClassName,
                                    "FULL_PATH", program.getMainProcessor().getFullyQualifiedReadableName());

        {
            auto indent = out.createIndentWithBraces();

            emitConstructor();
            emitInitialiseFunction();
            emitAdvanceFunction();

            out << sectionBreak;

            emitSaveStateFunctions();

            emitInputEndpointListFunctions();
            emitOutputEndpointListFunctions();

            emitInputAccessorFunctions();
            emitOutputAccessorFunctions();

            out << sectionBreak
                << "// Code beyond this point is private internal implementation detail"
                << sectionBreak;

            emitPackerFunctions();
            emitStringHandleLookup();
            emitWasmBytesFunction();
        }

        out << blankLine;

        return choc::text::replace (out.toString(),
                                    "$STATE_ADDRESS$", std::to_string (module.stateStructAddress),
                                    "$IO_ADDRESS$", std::to_string (module.ioStructAddress),
                                    "$INITIAL_NUM_MEM_PAGES$", std::to_string (module.initialNumMemPages),
                                    "$STACK_TOP$", std::to_string (module.stackTop));
    }

    //==============================================================================
    void emitConstructor()
    {
        out << choc::text::trimStart (R"(
/** After constructing one of these objects, call its
 *  initialise() method to prepare it for use.
 */
constructor()
)");
        auto indent2 = out.createIndentWithBraces();
    }

    void emitInitialiseFunction()
    {
        out << sectionBreak
            << choc::text::trimStart (R"js(
/** Prepares this processor for use.
 *
 *  @param {number} sessionID - A unique integer ID which will be used for `processor.session`.
 *  @param {number} frequency - The frequency in Hz that the processor will be expected to run at.
 */
async initialise (sessionID, frequency)
{
  if (! ((sessionID ^ 0) > 1))
    throw new Error ("initialise() requires a valid non-zero session ID argument");

  if (! (frequency > 1))
    throw new Error ("initialise() requires a valid frequency argument");

  const memory = new WebAssembly.Memory ({ initial: $INITIAL_NUM_MEM_PAGES$ });
  const stack = new WebAssembly.Global ({ value: "i32", mutable: true }, $STACK_TOP$);

  const imports = {
    env: {
      __linear_memory: memory,
      __memory_base: 0,
      __stack_pointer: stack,
      __table_base: 0,
      memcpy:  (dst, src, len) => { this.byteMemory.copyWithin (dst, src, src + len); return dst; },
      memmove: (dst, src, len) => { this.byteMemory.copyWithin (dst, src, src + len); return dst; },
      memset:  (dst, value, len) => { this.byteMemory.fill (value, dst, dst + len); return dst; }
    },
  };

  const result = await WebAssembly.instantiate (this._getWasmBytes(), imports);
  this.instance = result.instance;
  const exports = this.instance.exports;

  const memoryBuffer = exports.memory?.buffer || memory.buffer;
  this.byteMemory = new Uint8Array (memoryBuffer);
  this.memoryDataView = new DataView (memoryBuffer);

  if (exports.advanceBlock)
    this._advance = numFrames => exports.advanceBlock ($STATE_ADDRESS$, $IO_ADDRESS$, numFrames);
  else
    this._advance = () => exports.advanceOneFrame ($STATE_ADDRESS$, $IO_ADDRESS$);

  exports.initialise?.($STATE_ADDRESS$, sessionID, frequency);
  return true;
}
)js");
    }

    //==============================================================================
    void emitAdvanceFunction()
    {
        out << sectionBreak
            << choc::text::trimStart (R"(
/** Advances the processor by a number of frames.
 *
 *  Before calling `advance()` you should use the appropriate functions to
 *  push data and events into the processor's input endpoints. After calling
 *  `advance()` you can use its output endpoint access functions to read the
 *  results.
 *
 *  @param {number} numFrames - An integer number of frames to advance.
 *                              This must be greater than zero.
 */
advance (numFrames)
)");
        auto indent2 = out.createIndentWithBraces();

        for (auto& output : program.getMainProcessor().getOutputEndpoints (true))
        {
            if (output->isStream())
            {
                auto details = findOriginalEndpointDetails (output);
                auto info = getStreamInfo (details);

                out << "this.byteMemory.fill (0, " << info.address << ", ";

                if (buildSettings.getMaxBlockSize() == 1)
                    out << info.address + info.frameStride;
                else
                    out << info.address << " + numFrames * " << info.frameStride;

                out << ");" << newLine;
            }
        }

        out << "this._advance (numFrames);" << blankLine;
    }

    //==============================================================================
    void emitSaveStateFunctions()
    {
        out << sectionBreak
            << choc::text::trim (R"(
/** Returns an object which encapsulates the state of the patch at this point.
 *  The state can be restored by passing this object to `restoreState()`.
 */
getState()
{
  return { memory: this.byteMemory.slice(0) };
}

/** Restores the patch to a state that was previously saved by a call to `getState()`
 */
restoreState (savedState)
{
  if (savedState?.memory && savedState.memory?.length === this.byteMemory.length)
    this.byteMemory.set (savedState.memory);
  else
    throw Error ("restoreState(): not a valid state object");
}
)") << blankLine;
    }

    //==============================================================================
    void emitListReturnFunction (std::string_view name, const choc::value::ValueView& list)
    {
        out << name << "()" << newLine;

        {
            auto indent = out.createIndentWithBraces();
            out << "return " << choc::json::toString (list, true) << ";" << newLine;
        }

        out << blankLine;
    }

    void emitInputEndpointListFunctions()
    {
        auto list = choc::value::createEmptyArray();

        for (auto& output : program.getMainProcessor().getOutputEndpoints (true))
        {
            auto details = findOriginalEndpointDetails (output);
            list.addArrayElement (details.toJSON (false));
        }

        out << choc::text::trimStart (R"(
/** Returns a list of the output endpoints that this processor exposes.
 *  @returns {Array}
 */
)");
        emitListReturnFunction ("getOutputEndpoints", list);
    }

    void emitOutputEndpointListFunctions()
    {
        auto list = choc::value::createEmptyArray();

        for (auto& input : program.getMainProcessor().getInputEndpoints (true))
        {
            auto details = findOriginalEndpointDetails (input);
            list.addArrayElement (details.toJSON (false));
        }

        out << choc::text::trimStart (R"(
/** Returns a list of the input endpoints that this processor exposes.
 *  @returns {Array}
 */
)");
        emitListReturnFunction ("getInputEndpoints", list);
    }

    void emitInputAccessorFunctions()
    {
        for (auto& input : program.getMainProcessor().getInputEndpoints (true))
        {
            auto details = findOriginalEndpointDetails (input);
            auto endpointID = details.endpointID.toString();

            if (details.isStream())
            {
                emitInputStreamWriteFunction (details);
            }
            else if (details.isValue())
            {
                auto type = getEndpointTypePair (input, 0);

                out << textWithEndpointReplacement (endpointID, R"(
/** Sets the value of endpoint "ENDPOINT".
 *  @param {Object} newValue - The new value, whose type will depend on the endpoint type
 *  @param {number} numFramesToReachValue - If this is non-zero and the type is scalar,
 *                                          this applies a ramp to reach the new value.
*/
setInputValue_ENDPOINT (newValue, numFramesToReachValue)
)");
                {
                    auto indent = out.createIndentWithBraces();
                    auto setValueFunctionName = AST::getSetValueFunctionName (input);

                    out << "this." << getPackerFunctionName (type) << " (" << module.scratchSpaceAddress << ", newValue);" << newLine;
                    out << "this.instance.exports." << setValueFunctionName << " ($STATE_ADDRESS$, " << module.scratchSpaceAddress << ", numFramesToReachValue);" << newLine;
                }
            }
            else if (details.isEvent())
            {
                uint32_t index = 0;

                for (auto& eventType : input->getDataTypes())
                {
                    std::string params, paramVariable;

                    if (eventType->isVoid())
                    {
                        out << textWithEndpointReplacement (endpointID, R"(
/** Sends an event of type `void` to endpoint "ENDPOINT".
 */
)");
                        params = "()";
                        paramVariable = "undefined";
                    }
                    else
                    {
                        out << choc::text::replace (textWithEndpointReplacement (endpointID, R"(
/** Sends an event of type `$TYPE$` to endpoint "ENDPOINT".
 *  @param {$JSDOC_TYPE$} eventValue - The event to be added to the queue for this endpoint.
 */
)"),                        "$TYPE$", AST::print (eventType),
                            "$JSDOC_TYPE$", getJSDocType (eventType));

                        params = " (eventValue)";
                        paramVariable = "eventValue";
                    }

                    out << AST::getEventHandlerFunctionName (input, eventType, "sendInputEvent_") << params << newLine;

                    {
                        auto indent = out.createIndentWithBraces();

                        if (auto handlerFunction = AST::findEventHandlerFunction (input, eventType))
                        {
                            auto wasmEventHandlerFn = AST::getEventHandlerFunctionName (*handlerFunction);

                            if (isWASMPrimitive (eventType))
                            {
                                out << "this.instance.exports." << wasmEventHandlerFn << " ($STATE_ADDRESS$, "
                                    << paramVariable << ");" << newLine;
                            }
                            else
                            {
                                auto type = TypePair { eventType.get(), details.dataTypes[index++] };
                                out << "this." << getPackerFunctionName (type) << " (" << module.scratchSpaceAddress
                                    << ", " << paramVariable << ");" << newLine
                                    << "this.instance.exports." << wasmEventHandlerFn << " ($STATE_ADDRESS$, "
                                    << module.scratchSpaceAddress << ");" << newLine;
                            }
                        }
                    }

                    out << blankLine;
                }
            }

            out << blankLine;
        }
    }

    static std::string getJSDocType (const AST::TypeBase& t)
    {
        if (t.isPrimitiveInt() || t.isPrimitiveFloat()) return "number";
        if (t.isPrimitiveBool()) return "boolean";
        if (t.isPrimitiveString()) return "string";
        return "Object";
    }

    void emitOutputEventAccessorFunctions (const AST::EndpointDeclaration& output, const std::string& endpointID,
                                           const AST::StructType& stateStructType, uint32_t listIndex, uint32_t countIndex)
    {
        auto countPackedOffset = stateStructChocType.getElementTypeAndOffset (countIndex).offset;
        auto countNativeBit = stateStructLayout->convertPackedByteToNativeBit (static_cast<uint32_t> (countPackedOffset));
        auto countType = createTypePair (*stateStructType.getAggregateElementType (countIndex));

        out << textWithEndpointReplacement (endpointID, R"(
/** Returns the number of events available for endpoint "ENDPOINT" */
getOutputEventCount_ENDPOINT()
)");
        {
            auto indent = out.createIndentWithBraces();
            out << "return " << getUnpackFunctionCall (countType, std::to_string (module.stateStructAddress + countNativeBit / 8)) << ";" << newLine;
        }

        out << blankLine
            << textWithEndpointReplacement (endpointID, R"(
/** Resets the FIFO for event endpoint "ENDPOINT" */
resetOutputEventCount_ENDPOINT()
)");
        {
            auto indent = out.createIndentWithBraces();
            out << "this." << getPackerFunctionName (countType) << "(" << (module.stateStructAddress + countNativeBit / 8) << ", 0);" << newLine;
        }

        out << blankLine
            << textWithEndpointReplacement (endpointID, R"(
/** Returns one of the events from the FIFO for endpoint "ENDPOINT"
 *  @param {number} index - The index of the event to return
*/
getOutputEvent_ENDPOINT (index)
)");
        {
            auto indent = out.createIndentWithBraces();

            auto listArrayTypeAndOffset = stateStructChocType.getElementTypeAndOffset (listIndex);
            auto& eventArrayType = listArrayTypeAndOffset.elementType;
            auto eventArrayPackedOffsetFromState = static_cast<uint32_t> (listArrayTypeAndOffset.offset);
            CMAJ_ASSERT (eventArrayType.isArray() && eventArrayType.getNumElements() > 1);

            auto eventEntryChocType = eventArrayType.getElementType();
            auto& eventEntryASTType = *stateStructType.getMemberType (listIndex).getAggregateElementType(0);
            auto eventEntryTypePair = TypePair { eventEntryASTType, eventEntryChocType };

            auto eventEntryPackedSize = static_cast<uint32_t> (eventEntryChocType.getValueDataSize());
            auto eventArray0NativeOffset = stateStructLayout->convertPackedByteToNativeByte (eventArrayPackedOffsetFromState);
            auto eventArray1NativeOffset = stateStructLayout->convertPackedByteToNativeByte (eventArrayPackedOffsetFromState + eventEntryPackedSize);
            auto eventArrayNativeStride = eventArray1NativeOffset - eventArray0NativeOffset;

            auto readEventMember = [&] (uint32_t index)
            {
                auto memberOffsetWithinState = eventArrayPackedOffsetFromState + static_cast<uint32_t> (eventEntryChocType.getElementTypeAndOffset (index).offset);
                auto nativeMemberOffset = stateStructLayout->convertPackedByteToNativeByte (memberOffsetWithinState) - eventArray0NativeOffset;

                auto type = index >= 2 ? getEndpointTypePair (output, index - 2)
                                       : eventEntryTypePair.getElementType (index);

                return getUnpackFunctionCall (type, addToValue ("eventAddress", nativeMemberOffset));
            };

            out << "const eventAddress = " << (module.stateStructAddress + eventArray0NativeOffset) << " + (" << eventArrayNativeStride << " * index);" << newLine
                << "const frame = " << readEventMember (0) << ";" << newLine;

            auto numEventTypes = eventEntryChocType.getNumElements() - 2;

            if (numEventTypes == 1)
            {
                out << "return { frame, typeIndex: 0, event: " << readEventMember (2) << " };" << newLine;
            }
            else
            {
                out << "const typeIndex = " << readEventMember (1) << ";" << blankLine;

                out << "switch (typeIndex)" << newLine;
                {
                    auto switchIndent = out.createIndentWithBraces();

                    for (uint32_t i = 0; i < numEventTypes; ++i)
                        out << "case " << i << ": return { frame, typeIndex, event: " << readEventMember (i + 2) << " };" << newLine;
                }

                out << blankLine;
                out << "return { frame, typeIndex, event: null };" << newLine;
            }
        }
    }

    void emitOutputAccessorFunctions()
    {
        for (auto& output : program.getMainProcessor().getOutputEndpoints (true))
        {
            auto details = findOriginalEndpointDetails (output);
            auto endpointID = details.endpointID.toString();
            auto& stateStructType = AST::castToRef<AST::StructType> (*module.stateStructType);

            if (details.isStream())
            {
                emitOutputStreamReadFunction (details);
            }
            else if (details.isValue())
            {
                auto index = stateStructType.indexOfMember (StreamUtilities::getValueEndpointStructMemberName (endpointID));
                CMAJ_ASSERT (index >= 0);

                out << textWithEndpointReplacement (endpointID, R"(
/** Returns the current value of endpoint "ENDPOINT" */
getOutputValue_ENDPOINT()
)");
                {
                    auto indent = out.createIndentWithBraces();

                    auto valueTypeAndOffset = stateStructChocType.getElementTypeAndOffset (static_cast<uint32_t> (index));
                    auto packedOffsetInState = static_cast<uint32_t> (valueTypeAndOffset.offset);
                    auto nativeOffsetInState = stateStructLayout->convertPackedByteToNativeByte (packedOffsetInState);
                    auto typePair = getEndpointTypePair (output, 0);

                    out << "return " << getUnpackFunctionCall (typePair, std::to_string (module.stateStructAddress + nativeOffsetInState)) << ";" << newLine;
                }
            }
            else if (details.isEvent())
            {
                auto countIndex = stateStructType.indexOfMember (EventHandlerUtilities::getEventCountStateMemberName (endpointID));
                auto listIndex  = stateStructType.indexOfMember (endpointID);
                CMAJ_ASSERT (countIndex >= 0 && listIndex >= 0);

                emitOutputEventAccessorFunctions (output, endpointID, stateStructType,
                                                  static_cast<uint32_t> (listIndex),
                                                  static_cast<uint32_t> (countIndex));
            }

            out << blankLine;
        }
    }

    void emitOutputStreamReadFunction (EndpointDetails& details)
    {
        auto info = getStreamInfo (details);

        auto write = [&] (std::string_view code)
        {
            out << choc::text::replace (choc::text::trim (code),
                                        "$ADDRESS$", std::to_string (info.address),
                                        "$SRC_CHANS$", std::to_string (info.numChannels),
                                        "$UNPACK_SAMPLE$", getUnpackFunctionCall (info.sampleType, "source + $SAMPLE_STRIDE$ * channel"),
                                        "$MAX_NUM_FRAMES$", std::to_string (buildSettings.getMaxBlockSize()),
                                        "$FRAME_STRIDE$", std::to_string (info.frameStride),
                                        "$SAMPLE_STRIDE$", std::to_string (info.sampleStride))
                << newLine;
        };

        out << textWithEndpointReplacement (info.endpointID, R"(
/** Returns a frame from the output stream "ENDPOINT"
 *
 * @param {number} frameIndex - the index of the frame to fetch
 */
getOutputFrame_ENDPOINT (frameIndex)
)");
        {
            auto indent = out.createIndentWithBraces();
            write ("return " + getUnpackFunctionCall (info.frameType, "$ADDRESS$ + frameIndex * $FRAME_STRIDE$") + ";");
        }

        out << blankLine
            << textWithEndpointReplacement (info.endpointID, R"(
/** Copies frames from the output stream "ENDPOINT" into a destination array.
 *
 * @param {Array} destChannelArrays - An array of arrays (one per channel) into
 *                                    which the samples will be copied
 * @param {number} maxNumFramesToRead - The maximum number of frames to copy
 */
getOutputFrames_ENDPOINT (destChannelArrays, maxNumFramesToRead)
)");
        {
            auto indent = out.createIndentWithBraces();

            write (R"(
let source = $ADDRESS$;
let numDestChans = destChannelArrays.length;

if (maxNumFramesToRead > $MAX_NUM_FRAMES$)
  maxNumFramesToRead = $MAX_NUM_FRAMES$;

if (numDestChans < $SRC_CHANS$)
{
  for (let frame = 0; frame < maxNumFramesToRead; ++frame)
  {
    for (let channel = 0; channel < numDestChans; ++channel)
      destChannelArrays[channel][frame] = $UNPACK_SAMPLE$;

    source += $FRAME_STRIDE$;
  }
}
else if (numDestChans > $SRC_CHANS$)
{
  for (let frame = 0; frame < maxNumFramesToRead; ++frame)
  {
    let lastSample;

    for (let channel = 0; channel < $SRC_CHANS$; ++channel)
    {
      lastSample = $UNPACK_SAMPLE$;
      destChannelArrays[channel][frame] = lastSample;
    }

    for (let channel = $SRC_CHANS$; channel < numDestChans; ++channel)
      destChannelArrays[channel][frame] = lastSample;

    source += $FRAME_STRIDE$;
  }
}
else
{
  for (let frame = 0; frame < maxNumFramesToRead; ++frame)
  {
    for (let channel = 0; channel < $SRC_CHANS$; ++channel)
      destChannelArrays[channel][frame] = $UNPACK_SAMPLE$;

    source += $FRAME_STRIDE$;
  }
}
)");
        }
    }

    void emitInputStreamWriteFunction (EndpointDetails& details)
    {
        auto info = getStreamInfo (details);

        out << textWithEndpointReplacement (info.endpointID, R"(
/** Stores frames for the input to endpoint "ENDPOINT"
 *
 * @param {Array} sourceChannelArrays - An array of channel arrays to read
 * @param {number} numFramesToWrite - The number of frames to copy
 */
setInputStreamFrames_ENDPOINT (sourceChannelArrays, numFramesToWrite)
)");
        {
            auto indent = out.createIndentWithBraces();

            std::string_view code = R"(
try
{
  if (numFramesToWrite > $MAX_NUM_FRAMES$)
    numFramesToWrite = $MAX_NUM_FRAMES$;

  let dest = $ADDRESS$;

  if (sourceChannelArrays[0].length === undefined)  // If the input is a single channel
  {
    for (let frame = 0; frame < numFramesToWrite; ++frame)
    {
      const sourceSample = sourceChannelArrays[frame] || 0;

      for (let channel = 0; channel < $DST_CHANS$; ++channel)
        $PACK_SAMPLE$ (dest + $SAMPLE_STRIDE$ * channel, sourceSample);

      dest += $FRAME_STRIDE$;
    }
  }
  else
  {
    const numSourceChannels = sourceChannelArrays.length;

    for (let frame = 0; frame < numFramesToWrite; ++frame)
    {
      for (let channel = 0; channel < $DST_CHANS$; ++channel)
      {
        const sourceSample = channel < numSourceChannels ? (sourceChannelArrays[channel][frame] || 0) : 0;
        $PACK_SAMPLE$ (dest + $SAMPLE_STRIDE$ * channel, sourceSample);
      }

      dest += $FRAME_STRIDE$;
    }
  }
}
catch (error)
{
  // Sometimes, often at startup, Web Audio provides an empty buffer - causing TypeError on attempt to dereference
  if (!(error instanceof TypeError))
    throw(error);
}
)";

            out << choc::text::replace (choc::text::trim (code),
                                        "$ADDRESS$", std::to_string (info.address),
                                        "$DST_CHANS$", std::to_string (info.numChannels),
                                        "$MAX_NUM_FRAMES$", std::to_string (buildSettings.getMaxBlockSize()),
                                        "$PACK_SAMPLE$", std::string ("this.") + getPackerFunctionName (info.sampleType),
                                        "$FRAME_STRIDE$", std::to_string (info.frameStride),
                                        "$SAMPLE_STRIDE$", std::to_string (info.sampleStride))
                << newLine;
        }
    }

    void emitWasmBytesFunction()
    {
        out << "/** @access private */" << newLine
            << "_getWasmBytes()" << newLine;
        {
            auto indent = out.createIndentWithBraces();

            out << "return new Uint8Array([";

            size_t itemsOnLine = 0;

            for (auto byte : module.binaryWASMData)
            {
                if (++itemsOnLine > 200)
                {
                    itemsOnLine = 0;
                    out << newLine << "  ";
                }

                out << static_cast<uint8_t> (byte) << ",";
            }

            out << "]);" << newLine;
        }

        out << blankLine;
    }

    void emitPackerFunctions()
    {
        for (auto& packer : packerFunctions)
            writeTypePackerFunction (packer.type);

        for (auto& unpacker : unpackerFunctions)
            writeTypeUnpackerFunction (unpacker.type);
    }

    void emitStringHandleLookup()
    {
        if (module.stringDictionary.strings.empty())
            return;

        out << "/** @access private */" << newLine
            << "_getStringForHandle (handle)" << newLine;
        {
            auto indent = out.createIndentWithBraces();

            out << "switch (handle)" << newLine;
            {
                auto indent2 = out.createIndentWithBraces();

                auto stringData = module.stringDictionary.strings.data();
                auto totalLength = module.stringDictionary.strings.size();
                size_t offset = 0;

                for (;;)
                {
                    auto len = strnlen (stringData + offset, totalLength - offset);
                    auto s = std::string_view (stringData + offset, len);

                    out << "case " << offset + 1 << ": return " << choc::json::getEscapedQuotedString (s) << ";" << newLine;

                    offset += len + 1;

                    if (len == 0 || offset >= totalLength)
                        break;
                }
            }
        }

        out << blankLine;
    }

    //==============================================================================
    [[nodiscard]] static std::string textWithEndpointReplacement (std::string_view endpointID, std::string_view text)
    {
        return choc::text::replace (choc::text::trimStart (text), "ENDPOINT", endpointID);
    }

    // We can't create a new EndointDetails from an endpoint, because any types will have had
    // their multidimensional arrays flattened
    EndpointDetails findOriginalEndpointDetails (const AST::EndpointDeclaration& endpoint) const
    {
        for (auto& e : program.endpointList.inputEndpointDetails)
            if (e.endpointID == endpoint.getEndpointID())
                return e;

        for (auto& e : program.endpointList.outputEndpointDetails)
            if (e.endpointID == endpoint.getEndpointID())
                return e;

        CMAJ_ASSERT_FALSE;
        return {};
    }

    struct TypePair
    {
        ptr<const AST::TypeBase> astType;
        choc::value::Type chocType;

        TypePair getElementType (uint32_t index) const
        {
            if (chocType.isObject())
                return { *astType->getAggregateElementType (index),
                         chocType.getObjectMember (index).type };

            return { *astType->getAggregateElementType (index),
                     chocType.getElementType() };
        }
    };

    TypePair getEndpointTypePair (const AST::EndpointDeclaration& endpoint, size_t index) const
    {
        return { AST::castToTypeBaseRef (endpoint.dataTypes[index]),
                 findOriginalEndpointDetails (endpoint).dataTypes[index] };
    }

    TypePair createTypePair (const AST::TypeBase& type) const
    {
        return { type, module.getChocType (type) };
    }

    struct StreamInfo
    {
        std::string endpointID;
        uint32_t address, numChannels, frameStride, sampleStride;
        TypePair frameType, sampleType;
    };

    StreamInfo getStreamInfo (const EndpointDetails& details)
    {
        StreamInfo info;
        info.endpointID = details.endpointID.toString();

        const auto& ioStructType = AST::castToRef<AST::StructType> (module.ioStructType);
        auto index = ioStructType.indexOfMember (info.endpointID);
        CMAJ_ASSERT (index >= 0);

        auto memberTypeAndOffset = ioStructChocType.getElementTypeAndOffset (static_cast<uint32_t> (index));
        auto typePair = TypePair { ioStructType.getMemberType (static_cast<uint32_t> (index)), memberTypeAndOffset.elementType };

        auto packedOffsetInState = static_cast<uint32_t> (memberTypeAndOffset.offset);
        auto nativeOffsetInState = ioStructLayout->convertPackedByteToNativeByte (packedOffsetInState);
        info.address = module.ioStructAddress + nativeOffsetInState;

        if (buildSettings.getMaxBlockSize() == 1)
        {
            info.frameType = typePair;
            auto packedStride = static_cast<uint32_t> (typePair.chocType.getValueDataSize());
            info.frameStride = ioStructLayout->convertPackedByteToNativeByte (packedOffsetInState + packedStride) - nativeOffsetInState;
        }
        else
        {
            info.frameType = typePair.getElementType (0);
            auto packedStride = static_cast<uint32_t> (typePair.chocType.getElementTypeAndOffset (1).offset);
            info.frameStride = ioStructLayout->convertPackedByteToNativeByte (packedOffsetInState + packedStride) - nativeOffsetInState;
        }

        if (info.frameType.chocType.isVector())
        {
            info.numChannels = info.frameType.chocType.getNumElements();
            info.sampleType = info.frameType.getElementType (0);

            auto packedStride = static_cast<uint32_t> (info.sampleType.chocType.getValueDataSize());
            info.sampleStride = ioStructLayout->convertPackedByteToNativeByte (packedOffsetInState + packedStride) - nativeOffsetInState;
        }
        else
        {
            info.numChannels = 1;
            info.sampleType = info.frameType;
            info.sampleStride = info.frameStride;
        }

        return info;
    }

    static std::string addToValue (const std::string& value, size_t valueToAdd)
    {
        return valueToAdd == 0 ? value : (value + " + " + std::to_string (valueToAdd));
    }

    //==============================================================================
    std::string getPackerFunctionName (const TypePair& type)
    {
        auto name = "_pack_" + type.chocType.getSignature (true);

        for (auto& f : packerFunctions)
            if (f.name == name)
                return name;

        packerFunctions.push_back ({ type, name });
        return name;
    }

    std::string getUnpackFunctionCall (const TypePair& type, const std::string& address)
    {
        if (type.astType->isPrimitiveInt() || type.astType->isPrimitiveFloat())
            return getTypeUnpacker (*type.astType, type.chocType, address, 0);

        return "this." + getUnpackerFunctionName (type) + " (" + address + ")";
    }

    std::string getUnpackerFunctionName (const TypePair& type)
    {
        auto name = "_unpack_" + type.chocType.getSignature (true);

        for (auto& f : unpackerFunctions)
            if (f.name == name)
                return name;

        unpackerFunctions.push_back ({ type, name });
        return name;
    }

    void writeTypePackerFunction (const TypePair& type)
    {
        out << "/** @access private */" << newLine
            << getPackerFunctionName (type) << " (address, newValue)" << newLine;
        {
            auto indent = out.createIndentWithBraces();
            writeTypePacker (*type.astType, type.chocType, "address", 0, "newValue");
        }

        out << blankLine;
    }

    void writeTypeUnpackerFunction (const TypePair& type)
    {
        out << "/** @access private */" << newLine
            << getUnpackerFunctionName (type) << " (address)" << newLine;
        {
            auto indent = out.createIndentWithBraces();
            out << "return " << getTypeUnpacker (*type.astType, type.chocType, "address", 0) << ";" << newLine;
        }

        out << blankLine;
    }

    void writeTypePacker (const AST::TypeBase& baseType, const choc::value::Type& type,
                          const std::string& baseAddressVariable, uint32_t packedOffsetFromBase, const std::string& newValue)
    {
        auto writePrimitivePacker = [&] (std::string_view typeName, const std::string& v)
        {
            auto nativeOffset = module.nativeTypeLayouts.get (baseType)->convertPackedByteToNativeByte (packedOffsetFromBase);
            out << "this.memoryDataView.set" << typeName << " (" << addToValue (baseAddressVariable, nativeOffset)
                << ", " << v << ", " << (littleEndianPacking ? "true" : "false") << ");" << newLine;
        };

        if (type.isInt32())     return writePrimitivePacker ("Int32",    newValue);
        if (type.isFloat32())   return writePrimitivePacker ("Float32",  newValue);
        if (type.isInt64())     return writePrimitivePacker ("BigInt64", newValue);
        if (type.isFloat64())   return writePrimitivePacker ("Float64",  newValue);

        if (type.isBool())
        {
            auto nativeBit = module.nativeTypeLayouts.get (baseType)->convertPackedByteToNativeBit (packedOffsetFromBase);
            auto address = addToValue (baseAddressVariable, nativeBit / 8);
            auto onMask = static_cast<uint8_t> (1u << (nativeBit & 7));
            uint8_t offMask = ~onMask;

            out << "this.memoryDataView.setUint8 (" << address << ", " << newValue
                << " ? (" << onMask << " | this.memoryDataView.getUint8(" << address << "))"
                << " : (" << offMask << " & this.memoryDataView.getUint8(" << address << ")));" << newLine;

            return;
        }

        if (type.isArray() || type.isVector() || type.isObject())
        {
            for (uint32_t i = 0; i < type.getNumElements(); ++i)
            {
                auto element = type.getElementTypeAndOffset (i);
                auto indexSuffix = type.isObject() ? ("." + std::string (type.getObjectMember (i).name))
                                                            : ("[" + std::to_string (i) + "]");

                writeTypePacker (baseType, element.elementType, baseAddressVariable,
                                 packedOffsetFromBase + static_cast<uint32_t> (element.offset),
                                 newValue + indexSuffix);
            }

            return;
        }

        CMAJ_ASSERT_FALSE;
    }

    std::string getTypeUnpacker (const AST::TypeBase& baseType, const choc::value::Type& type,
                                 const std::string& baseAddressVariable, uint32_t packedOffsetFromBase)
    {
        auto getPrimitiveUnpacker = [&] (const std::string& typeName)
        {
            auto nativeOffset = module.nativeTypeLayouts.get (baseType)->convertPackedByteToNativeByte (packedOffsetFromBase);

            return "this.memoryDataView.get" + typeName + " (" + addToValue (baseAddressVariable, nativeOffset)
                     + (littleEndianPacking ? ", true)"
                                            : ", false)");
        };

        if (type.isInt32())     return getPrimitiveUnpacker ("Int32");
        if (type.isString())    return getPrimitiveUnpacker ("Int32");
        if (type.isFloat32())   return getPrimitiveUnpacker ("Float32");
        if (type.isInt64())     return getPrimitiveUnpacker ("BigInt64");
        if (type.isFloat64())   return getPrimitiveUnpacker ("Float64");

        if (type.isBool())
        {
            auto nativeBit = module.nativeTypeLayouts.get (baseType)->convertPackedByteToNativeBit (packedOffsetFromBase);
            auto address = addToValue (baseAddressVariable, nativeBit / 8);
            auto mask = static_cast<uint8_t> (1u << (nativeBit & 7));

            return "((this.memoryDataView.getUint8 (" + address + ") & " + std::to_string (mask) + ") !== 0)";
        }

        if (type.isArray() || type.isVector())
        {
            std::string s = "[";
            auto numElements = type.getNumElements();

            for (uint32_t i = 0; i < numElements; ++i)
            {
                if (i != 0)
                    s += ", ";

                auto element = type.getElementTypeAndOffset (i);
                s += getTypeUnpacker (baseType, element.elementType, baseAddressVariable,
                                      packedOffsetFromBase + static_cast<uint32_t> (element.offset));
            }

            return s + "]";
        }

        if (type.isObject())
        {
            std::string s = "{ ";
            auto numElements = type.getNumElements();

            for (uint32_t i = 0; i < numElements; ++i)
            {
                if (i != 0)
                    s += ", ";

                auto member = type.getObjectMember (i);
                auto memberOffset = static_cast<uint32_t> (type.getElementTypeAndOffset (i).offset);

                s += choc::json::getEscapedQuotedString (member.name)
                       + ": " + getTypeUnpacker (baseType, member.type, baseAddressVariable, packedOffsetFromBase + memberOffset);
            }

            return s + " }";
        }

        CMAJ_ASSERT_FALSE;
    }

    static bool isWASMPrimitive (const AST::TypeBase& type)
    {
        if (auto p = type.skipConstAndRefModifiers().getAsPrimitiveType())
            return p->isVoid() || p->isPrimitiveBool() || p->isPrimitiveInt()
                    || p->isPrimitiveFloat() || p->isPrimitiveString();

        return type.isEnum();
    }

    static constexpr bool littleEndianPacking = true;

    const AST::Program& program;
    WebAssemblyModule module;
    const BuildSettings& buildSettings;
    const bool useBinaryen;
    std::string mainClassName;
    ptr<const NativeTypeLayout> stateStructLayout, ioStructLayout;
    choc::value::Type stateStructChocType, ioStructChocType;

    struct PackingFunction
    {
        TypePair type;
        std::string name;
    };

    std::vector<PackingFunction> packerFunctions, unpackerFunctions;

    choc::text::CodePrinter out;

    static constexpr choc::text::CodePrinter::NewLine newLine = {};
    static constexpr choc::text::CodePrinter::BlankLine blankLine = {};
    static constexpr choc::text::CodePrinter::SectionBreak sectionBreak = {};
};

}

#endif
